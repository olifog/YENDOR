// ============================================================================
// Background Shader Module
// Dark swirling dungeon atmosphere effect
// ============================================================================

// ============================================================================
// GL Constants (prefixed to avoid conflicts with C macros)
// ============================================================================

MY_GL_VERTEX_SHADER := 35633.
MY_GL_FRAGMENT_SHADER := 35632.
MY_GL_ARRAY_BUFFER := 34962.
MY_GL_STATIC_DRAW := 35044.
MY_GL_TRIANGLES := 4.
MY_GL_FLOAT := 5126.
MY_GL_FALSE := 0.

// ============================================================================
// Shader State
// ============================================================================

bg_shader_prog := 0.
bg_vao := 0.
bg_vbo := 0.
bg_time_loc := 0.
bg_res_loc := 0.
bg_pos_loc := 0.
bg_shader_ready := 0.
bg_start_time := 0.

// ============================================================================
// Shader Sources - GLSL ES 300 for WebGL2
// ============================================================================

bg_vert_src := "#version 300 es
layout(location = 0) in vec2 aPos;
void main() {
    gl_Position = vec4(aPos, 0.0, 1.0);
}".

bg_frag_src := "#version 300 es
precision highp float;
out vec4 FragColor;
uniform float uTime;
uniform vec2 uResolution;
uniform vec2 uPlayerPos;

// Hash functions for noise
vec2 hash2(vec2 p) {
    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
}

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

// Perlin-style gradient noise
float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec2 u = f * f * (3.0 - 2.0 * f); // smoothstep
    
    return mix(
        mix(dot(hash2(i + vec2(0.0, 0.0)), f - vec2(0.0, 0.0)),
            dot(hash2(i + vec2(1.0, 0.0)), f - vec2(1.0, 0.0)), u.x),
        mix(dot(hash2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),
            dot(hash2(i + vec2(1.0, 1.0)), f - vec2(1.0, 1.0)), u.x),
        u.y
    );
}

// Fractal Brownian Motion - layered noise for cloud-like effect
float fbm(vec2 p, float t) {
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;
    
    // Layer multiple octaves of noise
    for (int i = 0; i < 6; i++) {
        // Drift each layer in different directions
        vec2 drift = vec2(
            t * 0.06 * (1.0 + float(i) * 0.3),
            t * 0.045 * (1.0 - float(i) * 0.2)
        );
        value += amplitude * noise(p * frequency + drift);
        frequency *= 2.0;
        amplitude *= 0.5;
    }
    return value;
}

void main() {
    vec2 uv = gl_FragCoord.xy / uResolution;
    vec2 p = (uv - 0.5) * 2.0;
    p.x *= uResolution.x / uResolution.y;
    
    float t = uTime / 1000.0;
    
    // === Mysterious Cloud Background ===
    
    // Multiple cloud layers at different scales and speeds - higher frequency for more shapes
    float cloud1 = fbm(p * 1.5 + vec2(t * 0.08, t * 0.06), t * 1.5);
    float cloud2 = fbm(p * 2.0 + vec2(-t * 0.06, t * 0.1), t * 2.0);
    float cloud3 = fbm(p * 1.0 + vec2(t * 0.03, -t * 0.045), t * 1.0);
    float cloud4 = fbm(p * 2.5 + vec2(t * 0.05, t * 0.08), t * 1.8);
    
    // Combine clouds with different weights
    float clouds = cloud1 * 0.4 + cloud2 * 0.25 + cloud3 * 0.2 + cloud4 * 0.25;
    clouds = clouds * 0.5 + 0.5; // Normalize to 0-1
    
    // Create depth with moving shapes - more of them
    float bigShape = noise(p * 0.8 + vec2(t * 0.025, t * 0.02));
    float medShape = noise(p * 1.2 + vec2(-t * 0.035, t * 0.03));
    float smallShape = noise(p * 2.0 + vec2(t * 0.04, -t * 0.025));
    
    // Mysterious purple color palette - visible but moody
    vec3 deepVoid = vec3(0.02, 0.01, 0.04);      // Dark base
    vec3 darkPurple = vec3(0.08, 0.03, 0.14);    // Deep violet
    vec3 midPurple = vec3(0.14, 0.05, 0.22);     // Rich purple
    vec3 mistPurple = vec3(0.20, 0.08, 0.30);    // Lighter mist
    vec3 accentBlue = vec3(0.05, 0.07, 0.15);    // Deep blue hints
    vec3 highlight = vec3(0.25, 0.12, 0.35);     // Bright purple accent
    
    // Build color from cloud layers
    vec3 col = deepVoid;
    
    // Base cloud shapes at different scales
    col = mix(col, darkPurple, smoothstep(-0.3, 0.3, bigShape) * 0.7);
    col = mix(col, accentBlue, smoothstep(-0.2, 0.4, medShape) * 0.5);
    col = mix(col, midPurple, smoothstep(-0.1, 0.3, smallShape) * 0.4);
    
    // Layered cloud detail
    col = mix(col, midPurple, smoothstep(0.35, 0.6, clouds) * 0.6);
    
    // Bright wisps in the thickest cloud areas
    float wisps = smoothstep(0.55, 0.85, clouds);
    col = mix(col, mistPurple, wisps * 0.5);
    
    // Highlights in densest regions
    float peaks = smoothstep(0.75, 0.95, clouds);
    col = mix(col, highlight, peaks * 0.3);
    
    // Subtle shifting glow
    float glow = sin(t * 0.5 + cloud1 * 3.0) * 0.5 + 0.5;
    col += vec3(0.04, 0.015, 0.06) * glow * smoothstep(0.4, 0.8, clouds);
    
    // === Torch Light Effect ===
    float dist = length(gl_FragCoord.xy - uPlayerPos);
    
    // Flickering torch
    float flicker = sin(t * 5.0) * 0.15 + cos(t * 7.0) * 0.05 + hash(vec2(floor(t * 20.0), 0.0)) * 0.1;
    float radius = 25.0 + flicker * 20.0;
    
    float atten = 1.0 - smoothstep(radius * 0.1, radius, dist);
    
    // Warm torch colors contrasting with purple
    vec3 torchColor = vec3(1.0, 0.75, 0.4);
    vec3 glowColor = vec3(0.7, 0.25, 0.15);
    
    vec3 light = mix(glowColor, torchColor, smoothstep(radius * 0.6, 0.0, dist));
    
    vec3 finalCol = col + light * atten * 0.5;
    
    // Subtle vignette
    float r = length(p);
    float vig = 1.0 - smoothstep(0.5, 1.8, r);
    finalCol *= 0.75 + 0.25 * vig;
    
    FragColor = vec4(finalCol, 1.0);
}".

// ============================================================================
// Shader Initialization
// ============================================================================

#init_background_shader() >
    /console_log/"Initializing background shader...".
    
    // Create and compile vertex shader
    vs := /gl_create_shader/MY_GL_VERTEX_SHADER.
    vs_ok := /gl_shader_source_compile/vs/bg_vert_src.
    /console_log/"Vertex shader failed!" when vs_ok == 0.
    
    // Create and compile fragment shader
    fs := /gl_create_shader/MY_GL_FRAGMENT_SHADER.
    fs_ok := /gl_shader_source_compile/fs/bg_frag_src.
    /console_log/"Fragment shader failed!" when fs_ok == 0.
    
    // Create and link program
    bg_shader_prog = /gl_create_program/.
    /gl_attach_shader/bg_shader_prog/vs.
    /gl_attach_shader/bg_shader_prog/fs.
    link_ok := /gl_link_program/bg_shader_prog.
    /console_log/"Shader link failed!" when link_ok == 0.
    
    // Clean up shaders (they're in the program now)
    /gl_delete_shader/vs.
    /gl_delete_shader/fs.
    
    // Get uniform locations
    bg_time_loc = /gl_get_uniform_location/bg_shader_prog/"uTime".
    bg_res_loc = /gl_get_uniform_location/bg_shader_prog/"uResolution".
    bg_pos_loc = /gl_get_uniform_location/bg_shader_prog/"uPlayerPos".
    
    // Create VAO and VBO for fullscreen quad
    bg_vao = /gl_create_vertex_array/.
    bg_vbo = /gl_create_buffer/.
    
    /gl_bind_vertex_array/bg_vao.
    /gl_bind_buffer/MY_GL_ARRAY_BUFFER/bg_vbo.
    
    // Create vertex data for fullscreen quad (two triangles)
    // Vertices: [-1,-1], [1,-1], [-1,1], [1,-1], [1,1], [-1,1]
    quad_buf := /buf_create_floats/12.
    neg1 := 0.0f - 1.0f.
    /buf_set_float/quad_buf/0/neg1.   // v0.x
    /buf_set_float/quad_buf/1/neg1.   // v0.y
    /buf_set_float/quad_buf/2/1.0f.   // v1.x
    /buf_set_float/quad_buf/3/neg1.   // v1.y
    /buf_set_float/quad_buf/4/neg1.   // v2.x
    /buf_set_float/quad_buf/5/1.0f.   // v2.y
    /buf_set_float/quad_buf/6/1.0f.   // v3.x
    /buf_set_float/quad_buf/7/neg1.   // v3.y
    /buf_set_float/quad_buf/8/1.0f.   // v4.x
    /buf_set_float/quad_buf/9/1.0f.   // v4.y
    /buf_set_float/quad_buf/10/neg1.  // v5.x
    /buf_set_float/quad_buf/11/1.0f.  // v5.y
    
    // Upload to GPU
    /buf_upload/MY_GL_ARRAY_BUFFER/quad_buf/MY_GL_STATIC_DRAW.
    /buf_free/quad_buf.
    
    // Set up vertex attribute
    /gl_enable_vertex_attrib_array/0.
    /gl_vertex_attrib_pointer/0/2/MY_GL_FLOAT/MY_GL_FALSE/0/0.
    
    // Unbind
    /gl_bind_buffer/MY_GL_ARRAY_BUFFER/0.
    /gl_bind_vertex_array/0.
    
    bg_start_time = /time_ms/.
    bg_shader_ready = 1.
    /console_log/"Background shader ready!".
<

// ============================================================================
// Render Background
// ============================================================================

#render_background(px, py) >
    << 0 when bg_shader_ready == 0.
    
    // Calculate elapsed time in milliseconds
    now := /time_ms/.
    elapsed := now - bg_start_time.
    
    // Use our shader program
    /gl_use_program/bg_shader_prog.
    
    // Set uniforms
    /gl_uniform1f/bg_time_loc/elapsed.
    
    // Get dynamic screen dimensions
    sw := /get_screen_width/.
    sh := /get_screen_height/.
    sw_f := sw * 1.0f.
    sh_f := sh * 1.0f.
    /gl_uniform2f/bg_res_loc/sw_f/sh_f.
    
    // Convert game Y (down) to GL Y (up)
    py_f := py * 1.0f.
    gl_py := sh_f - py_f.
    // Adjust slightly to center on character (approx half tile height)
    gl_py = gl_py - 8.0f. 
    px_f := px * 1.0f + 5.0f. // Center on width (avg tile width 10)
    
    /gl_uniform2f/bg_pos_loc/px_f/gl_py.
    
    // Draw fullscreen quad
    /gl_bind_vertex_array/bg_vao.
    /gl_draw_arrays/MY_GL_TRIANGLES/0/6.
    
    // Reset state for text rendering (fixed-function)
    /gl_bind_vertex_array/0.
    /gl_use_program/0.
<

