// ============================================================================
// Bot Interpreter Module
// Runs user code from the editor to control the bot
// ============================================================================

// ============================================================================
// AST Tags (from interpreter/ast.nh)
// ============================================================================

BOT_TAG_LIT := 1.
BOT_TAG_VAR := 2.
BOT_TAG_ADD := 3.
BOT_TAG_SUB := 8.
BOT_TAG_MUL := 9.
BOT_TAG_DIV := 10.
BOT_TAG_MOD := 11.
BOT_TAG_LT := 12.
BOT_TAG_GT := 13.
BOT_TAG_LE := 14.
BOT_TAG_GE := 15.
BOT_TAG_EQ := 16.
BOT_TAG_NE := 17.
BOT_TAG_AND := 18.
BOT_TAG_OR := 19.
BOT_TAG_NOT := 20.
BOT_TAG_DECL := 4.
BOT_TAG_SEQ := 5.
BOT_TAG_ASSIGN := 7.
BOT_TAG_LOOP := 21.
BOT_TAG_BREAK := 22.
BOT_TAG_IF := 23.
BOT_TAG_WHEN := 24.
BOT_TAG_FOR := 25.
BOT_TAG_FUNC := 26.
BOT_TAG_CALL := 27.
BOT_TAG_RETURN := 28.
BOT_TAG_MATCH := 29.
BOT_TAG_MATCH_ARM := 30.
BOT_TAG_WILDCARD := 31.
BOT_TAG_STRING := 32.
BOT_TAG_ARRAY := 33.
BOT_TAG_INDEX := 34.
BOT_TAG_OBJECT := 35.
BOT_TAG_FIELD := 36.
BOT_TAG_PROP := 37.
BOT_TAG_LAMBDA := 38.

// ============================================================================
// Token Types (from interpreter/lexer.nh)
// ============================================================================

BOT_TOK_INT := 1.
BOT_TOK_IDENT := 2.
BOT_TOK_PLUS := 3.
BOT_TOK_MINUS := 4.
BOT_TOK_STAR := 5.
BOT_TOK_SLASH := 6.
BOT_TOK_PERCENT := 7.
BOT_TOK_ASSIGN := 8.
BOT_TOK_DOT := 9.
BOT_TOK_EOF := 10.
BOT_TOK_LPAREN := 11.
BOT_TOK_RPAREN := 12.
BOT_TOK_LT := 13.
BOT_TOK_GT := 14.
BOT_TOK_LE := 15.
BOT_TOK_GE := 16.
BOT_TOK_EQ := 17.
BOT_TOK_NE := 18.
BOT_TOK_AND := 19.
BOT_TOK_OR := 20.
BOT_TOK_NOT := 21.
BOT_TOK_LOOP := 22.
BOT_TOK_WHEN := 23.
BOT_TOK_UNLESS := 24.
BOT_TOK_IF := 25.
BOT_TOK_ELSE := 26.
BOT_TOK_BREAK := 27.
BOT_TOK_SCOPE_IN := 28.
BOT_TOK_SCOPE_OUT := 29.
BOT_TOK_FOR := 30.
BOT_TOK_IN := 31.
BOT_TOK_RANGE := 32.
BOT_TOK_HASH := 33.
BOT_TOK_RETURN := 34.
BOT_TOK_COMMA := 35.
BOT_TOK_PIPE := 36.
BOT_TOK_ARROW := 37.
BOT_TOK_UNDER := 38.
BOT_TOK_STRING := 39.
BOT_TOK_LBRACKET := 40.
BOT_TOK_RBRACKET := 41.
BOT_TOK_LBRACE := 42.
BOT_TOK_RBRACE := 43.
BOT_TOK_COLON := 44.
BOT_TOK_PROPACCESS := 45.
BOT_TOK_BACKSLASH := 46.

// ============================================================================
// Bot Interpreter State
// ============================================================================

bot_ast := 0.          // The parsed AST
bot_env := 0.          // The execution environment
bot_is_running := 0.   // 1 if continuously running, 0 if stopped
bot_is_stepping := 0.  // 1 if we're in step mode
bot_step_timer := 0.   // Timer for continuous run delay
bot_step_delay := 500. // Delay between steps in continuous mode (ms)
bot_error := "".       // Error message if any
bot_has_error := 0.    // 1 if there's an error

// Step counter for display
bot_step_count := 0.

// Current execution line (0-indexed, -1 = not running)
bot_current_line := 0 - 1.

// Code hash for detecting edits (simple checksum)
bot_code_hash := 0.

// Statement list for line-by-line execution
bot_statements := [].      // Array of statement AST nodes
bot_stmt_lines := [].      // Array of line numbers for each statement
bot_stmt_count := 0.       // Number of statements
bot_stmt_index := 0.       // Current statement index (which one to execute next)

// Flag for when bot action happens (for animation timing)
bot_did_move := 0.

// Yield state - for pausing execution mid-loop
bot_yield := 0.            // 1 if we should pause execution
bot_in_loop := 0.          // 1 if we're suspended inside a loop
bot_loop_node := 0.        // The loop AST node we're in
bot_loop_iter := 0.        // Current iteration (for for-loops)
bot_loop_var := "".        // Loop variable name (for for-loops)
bot_loop_end := 0.         // Loop end value (for for-loops)
bot_loop_env := 0.         // Environment for the loop

// Loop body stepping - for line-by-line within loops
bot_loop_body_stmts := []. // Flattened statements in loop body
bot_loop_body_count := 0.  // Number of statements in loop body
bot_loop_body_idx := 0.    // Current statement index within body

// Print output for debugging
bot_print_buffer := 0.     // Last printed value
bot_has_print := 0.        // 1 if there's a value to display

// ============================================================================
// AST Constructors
// ============================================================================

#bot_lit(value) => { tag: BOT_TAG_LIT, value: value }.
#bot_var(name)  => { tag: BOT_TAG_VAR, name: name }.
#bot_add(a, b)  => { tag: BOT_TAG_ADD, a: a, b: b }.
#bot_sub(a, b)  => { tag: BOT_TAG_SUB, a: a, b: b }.
#bot_mul(a, b)  => { tag: BOT_TAG_MUL, a: a, b: b }.
#bot_div(a, b)  => { tag: BOT_TAG_DIV, a: a, b: b }.
#bot_mod(a, b)  => { tag: BOT_TAG_MOD, a: a, b: b }.
#bot_lt_op(a, b)   => { tag: BOT_TAG_LT, a: a, b: b }.
#bot_gt_op(a, b)   => { tag: BOT_TAG_GT, a: a, b: b }.
#bot_le_op(a, b)   => { tag: BOT_TAG_LE, a: a, b: b }.
#bot_ge_op(a, b)   => { tag: BOT_TAG_GE, a: a, b: b }.
#bot_eq_op(a, b)   => { tag: BOT_TAG_EQ, a: a, b: b }.
#bot_ne_op(a, b)   => { tag: BOT_TAG_NE, a: a, b: b }.
#bot_and_op(a, b) => { tag: BOT_TAG_AND, a: a, b: b }.
#bot_or_op(a, b)  => { tag: BOT_TAG_OR, a: a, b: b }.
#bot_not_op(a)    => { tag: BOT_TAG_NOT, a: a }.
#bot_decl(name, expr, line) => { tag: BOT_TAG_DECL, name: name, expr: expr, line: line }.
#bot_seq(a, b)  => { tag: BOT_TAG_SEQ, a: a, b: b, line: a->line }.
#bot_assign(name, expr, line) => { tag: BOT_TAG_ASSIGN, name: name, expr: expr, line: line }.
#bot_loop_stmt(body) => { tag: BOT_TAG_LOOP, body: body }.
#bot_break_stmt() => { tag: BOT_TAG_BREAK }.
#bot_if_expr(cond, then_br, else_br) => { tag: BOT_TAG_IF, cond: cond, then_br: then_br, else_br: else_br }.
#bot_when_stmt(stmt, cond, line) => { tag: BOT_TAG_WHEN, stmt: stmt, cond: cond, line: line }.
#bot_for_stmt(var, start, end, body) => { tag: BOT_TAG_FOR, var: var, start: start, end: end, body: body }.
#bot_func_def(name, params, body) => { tag: BOT_TAG_FUNC, name: name, params: params, body: body }.
#bot_func_call(name, args, line) => { tag: BOT_TAG_CALL, name: name, args: args, line: line }.
#bot_return_stmt(expr) => { tag: BOT_TAG_RETURN, expr: expr }.
#bot_match_expr(value, arms) => { tag: BOT_TAG_MATCH, value: value, arms: arms }.
#bot_match_arm(pattern, body) => { tag: BOT_TAG_MATCH_ARM, pattern: pattern, body: body }.
#bot_wildcard() => { tag: BOT_TAG_WILDCARD }.
#bot_str_lit(value) => { tag: BOT_TAG_STRING, value: value }.
#bot_arr_lit(elements) => { tag: BOT_TAG_ARRAY, elements: elements }.
#bot_index_op(arr, idx) => { tag: BOT_TAG_INDEX, arr: arr, idx: idx }.
#bot_obj_lit(fields) => { tag: BOT_TAG_OBJECT, fields: fields }.
#bot_obj_field(key, value) => { tag: BOT_TAG_FIELD, key: key, value: value }.
#bot_prop_op(obj, key) => { tag: BOT_TAG_PROP, obj: obj, key: key }.
#bot_lambda_expr(params, body) => { tag: BOT_TAG_LAMBDA, params: params, body: body }.

// ============================================================================
// Token Constructor
// ============================================================================

#bot_token(type, value, line) >
    t := /ds_object_create/0.
    /ds_set_prop/t/"type"/type.
    /ds_set_prop/t/"value"/value.
    /ds_set_prop/t/"line"/line.
    << t.
<

// Current line during tokenization
bot_lex_line := 0.

// ============================================================================
// Lexer Helpers
// ============================================================================

#bot_is_digit(c) => c ge 48 and c le 57.
#bot_is_alpha(c) => (c ge 65 and c le 90) or (c ge 97 and c le 122) or c == 95.
#bot_is_space(c) => c == 32 or c == 10 or c == 9 or c == 13.

#bot_parse_int(str, start) >
    len := /ds_strlen/str.
    val := 0.
    i := start.
    loop >
        c := /ds_string_at/str/i.
        >> when i ge len or not (/bot_is_digit/c).
        val = val * 10 + (c - 48).
        i = i + 1.
    <
    << { val: val, end: i }.
<

#bot_parse_ident(str, start) >
    len := /ds_strlen/str.
    i := start.
    
    loop >
        c := /ds_string_at/str/i.
        >> when i ge len.
        >> when not (/bot_is_alpha/c) and not (/bot_is_digit/c).
        i = i + 1.
    <
    
    val := /ds_substring/str/start/(i - start).
    << { val: val, end: i }.
<

#bot_tokenize_digit(str, i, tokens) >
    res := /bot_parse_int/str/i.
    /ds_list_push/tokens/(/bot_token/BOT_TOK_INT/res->val/bot_lex_line).
    << res->end.
<

#bot_tokenize_string(str, i, tokens) >
    i = i + 1.
    start := i.
    len := /ds_strlen/str.
    
    loop >
        >> when i ge len.
        c := /ds_string_at/str/i.
        >> when c == 34.
        i = i + 1.
    <
    
    val := /ds_substring/str/start/(i - start).
    /ds_list_push/tokens/(/bot_token/BOT_TOK_STRING/val/bot_lex_line).
    << i + 1.
<

#bot_tokenize_alpha(str, i, tokens) >
    res := /bot_parse_ident/str/i.
    s := res->val.
    
    type := BOT_TOK_IDENT.
    
    type = (/ds_streq/s/"lt") | > 1 => BOT_TOK_LT _ => type <.
    type = (/ds_streq/s/"gt") | > 1 => BOT_TOK_GT _ => type <.
    type = (/ds_streq/s/"le") | > 1 => BOT_TOK_LE _ => type <.
    type = (/ds_streq/s/"ge") | > 1 => BOT_TOK_GE _ => type <.
    type = (/ds_streq/s/"eq") | > 1 => BOT_TOK_EQ _ => type <.
    type = (/ds_streq/s/"ne") | > 1 => BOT_TOK_NE _ => type <.
    type = (/ds_streq/s/"and") | > 1 => BOT_TOK_AND _ => type <.
    type = (/ds_streq/s/"or") | > 1 => BOT_TOK_OR _ => type <.
    type = (/ds_streq/s/"not") | > 1 => BOT_TOK_NOT _ => type <.
    type = (/ds_streq/s/"loop") | > 1 => BOT_TOK_LOOP _ => type <.
    type = (/ds_streq/s/"when") | > 1 => BOT_TOK_WHEN _ => type <.
    type = (/ds_streq/s/"unless") | > 1 => BOT_TOK_UNLESS _ => type <.
    type = (/ds_streq/s/"if") | > 1 => BOT_TOK_IF _ => type <.
    type = (/ds_streq/s/"else") | > 1 => BOT_TOK_ELSE _ => type <.
    type = (/ds_streq/s/"for") | > 1 => BOT_TOK_FOR _ => type <.
    type = (/ds_streq/s/"in") | > 1 => BOT_TOK_IN _ => type <.
    
    val := (type == BOT_TOK_IDENT) | > 1 => s 0 => 0 <.
    
    /ds_list_push/tokens/(/bot_token/type/val/bot_lex_line).
    << res->end.
<

#bot_skip_comment(str, i) >
    len := /ds_strlen/str.
    loop >
        >> when i ge len.
        c := /ds_string_at/str/i.
        >> when c == 10.
        i = i + 1.
    <
    << i.
<

#bot_do(a, b) => b.

#bot_tokenize_symbol(str, i, tokens) >
    c := /ds_string_at/str/i.
    next := /ds_string_at/str/(i + 1).
    ln := bot_lex_line.
    
    // Check for // comment
    is_comment := (c == 47 and next == 47).
    << /bot_skip_comment/str/i when is_comment.
    
    // Check for ==
    is_eq := (c == 61 and next == 61).
    << /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_EQ/0/ln))/(i + 2) when is_eq.
    
    // Check for !=
    is_neq := (c == 33 and next == 61).
    << /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_NE/0/ln))/(i + 2) when is_neq.
    
    // Check for >>
    is_break := (c == 62 and next == 62).
    << /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_BREAK/0/ln))/(i + 2) when is_break.
    
    // Check for ..
    is_range := (c == 46 and next == 46).
    << /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_RANGE/0/ln))/(i + 2) when is_range.

    // Check for << (return)
    is_return := (c == 60 and next == 60).
    << /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_RETURN/0/ln))/(i + 2) when is_return.

    // Check for => (arrow)
    is_arrow := (c == 61 and next == 62).
    << /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_ARROW/0/ln))/(i + 2) when is_arrow.

    // Check for -> (property access)
    is_prop := (c == 45 and next == 62).
    << /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_PROPACCESS/0/ln))/(i + 2) when is_prop.

    // Check for := (declaration)
    is_decl := (c == 58 and next == 61).
    << /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_ASSIGN/0/ln))/(i + 2) when is_decl.

    // Single char
    << c | >
        43 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_PLUS/0/ln))/(i + 1)
        45 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_MINUS/0/ln))/(i + 1)
        42 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_STAR/0/ln))/(i + 1)
        47 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_SLASH/0/ln))/(i + 1)
        37 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_PERCENT/0/ln))/(i + 1)
        46 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_DOT/0/ln))/(i + 1)
        61 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_ASSIGN/0/ln))/(i + 1)
        40 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_LPAREN/0/ln))/(i + 1)
        41 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_RPAREN/0/ln))/(i + 1)
        60 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_SCOPE_OUT/0/ln))/(i + 1)
        62 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_SCOPE_IN/0/ln))/(i + 1)
        35 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_HASH/0/ln))/(i + 1)
        44 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_COMMA/0/ln))/(i + 1)
        124 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_PIPE/0/ln))/(i + 1)
        95 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_UNDER/0/ln))/(i + 1)
        91 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_LBRACKET/0/ln))/(i + 1)
        93 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_RBRACKET/0/ln))/(i + 1)
        123 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_LBRACE/0/ln))/(i + 1)
        125 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_RBRACE/0/ln))/(i + 1)
        58 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_COLON/0/ln))/(i + 1)
        92 => /bot_do/(/ds_list_push/tokens/(/bot_token/BOT_TOK_BACKSLASH/0/ln))/(i + 1)
        _ => (i + 1)
    <.
<

#bot_tokenize(str) >
    tokens := /ds_list_create/.
    len := /ds_strlen/str.
    i := 0.
    bot_lex_line = 0.
    
    loop >
        >> when i ge len.
        c := /ds_string_at/str/i.
        
        // Track newlines
        bot_lex_line = bot_lex_line + 1 when c == 10.
        
        i = (
            /bot_is_space/c | >
                1 => i + 1
                0 => (
                    /bot_is_digit/c | >
                        1 => /bot_tokenize_digit/str/i/tokens
                        0 => (
                            /bot_is_alpha/c | >
                                1 => /bot_tokenize_alpha/str/i/tokens
                                0 => (
                                    c == 34 | >
                                        1 => /bot_tokenize_string/str/i/tokens
                                        0 => /bot_tokenize_symbol/str/i/tokens
                                    <
                                )
                            <
                        )
                    <
                )
            <
        ).
    <
    
    /ds_list_push/tokens/(/bot_token/BOT_TOK_EOF/0/bot_lex_line).
    << tokens.
<

// ============================================================================
// Parser
// ============================================================================

#bot_peek(tokens, pos) >
    << /ds_list_get/tokens/pos.
<

#bot_parse_paren(tokens, pos) >
    res := /bot_parse_expr/tokens/(pos + 1).
    end := res->end.
    rparen := /bot_peek/tokens/end.
    end = (rparen->type == BOT_TOK_RPAREN) | > 1 => end + 1 0 => end <.
    << { node: res->node, end: end }.
<

#bot_parse_array(tokens, pos) >
    pos = pos + 1.
    
    elements := /ds_list_create/.
    loop >
        tok := /bot_peek/tokens/pos.
        >> when tok->type == BOT_TOK_RBRACKET.
        
        elem_res := /bot_parse_expr/tokens/pos.
        /ds_list_push/elements/elem_res->node.
        pos = elem_res->end.
        
        tok = /bot_peek/tokens/pos.
        pos = pos + 1 when tok->type == BOT_TOK_COMMA.
    <
    
    pos = pos + 1.
    << { node: /bot_arr_lit/elements, end: pos }.
<

#bot_parse_object(tokens, pos) >
    pos = pos + 1.
    
    fields := /ds_list_create/.
    loop >
        tok := /bot_peek/tokens/pos.
        >> when tok->type == BOT_TOK_RBRACE.
        
        key := tok->value.
        pos = pos + 1.
        pos = pos + 1.
        
        val_res := /bot_parse_expr/tokens/pos.
        pos = val_res->end.
        
        /ds_list_push/fields/(/bot_obj_field/key/val_res->node).
        
        tok = /bot_peek/tokens/pos.
        pos = pos + 1 when tok->type == BOT_TOK_COMMA.
    <
    
    pos = pos + 1.
    << { node: /bot_obj_lit/fields, end: pos }.
<

#bot_parse_lambda(tokens, pos) >
    pos = pos + 2.
    
    params := /ds_list_create/.
    loop >
        tok := /bot_peek/tokens/pos.
        >> when tok->type == BOT_TOK_RPAREN.
        
        /ds_list_push/params/tok->value.
        pos = pos + 1.
        
        tok = /bot_peek/tokens/pos.
        pos = pos + 1 when tok->type == BOT_TOK_COMMA.
    <
    
    pos = pos + 1.
    pos = pos + 1.
    
    body_res := /bot_parse_expr/tokens/pos.
    
    << { node: /bot_lambda_expr/params/body_res->node, end: body_res->end }.
<

#bot_parse_primary_base(tokens, pos) >
    tok := /bot_peek/tokens/pos.
    << tok->type | >
        1 => { node: /bot_lit/tok->value, end: pos + 1 }
        2 => { node: /bot_var/tok->value, end: pos + 1 }
        11 => /bot_parse_paren/tokens/pos
        21 => /bot_parse_not/tokens/pos
        6 => /bot_parse_call_expr/tokens/pos
        38 => { node: /bot_wildcard/, end: pos + 1 }
        39 => { node: /bot_str_lit/tok->value, end: pos + 1 }
        40 => /bot_parse_array/tokens/pos
        42 => /bot_parse_object/tokens/pos
        46 => /bot_parse_lambda/tokens/pos
        _ => { node: /bot_lit/0, end: pos }
    <.
<

#bot_parse_primary(tokens, pos) >
    res := /bot_parse_primary_base/tokens/pos.
    << /bot_parse_primary_postfix/tokens/res->end/res->node.
<

#bot_parse_index_rest(tokens, pos, node) >
    pos = pos + 1.
    idx_res := /bot_parse_expr/tokens/pos.
    pos = idx_res->end.
    pos = pos + 1.
    new_node := /bot_index_op/node/idx_res->node.
    << /bot_parse_primary_postfix/tokens/pos/new_node.
<

#bot_parse_prop_rest(tokens, pos, node) >
    pos = pos + 1.
    key_tok := /bot_peek/tokens/pos.
    key := key_tok->value.
    pos = pos + 1.
    new_node := /bot_prop_op/node/key.
    << /bot_parse_primary_postfix/tokens/pos/new_node.
<

#bot_parse_primary_postfix(tokens, pos, node) >
    tok := /bot_peek/tokens/pos.
    
    << /bot_parse_index_rest/tokens/pos/node when tok->type == BOT_TOK_LBRACKET.
    << /bot_parse_prop_rest/tokens/pos/node when tok->type == BOT_TOK_PROPACCESS.
    
    << { node: node, end: pos }.
<

#bot_parse_not(tokens, pos) >
    pos = pos + 1.
    res := /bot_parse_primary/tokens/pos.
    << { node: /bot_not_op/res->node, end: res->end }.
<

#bot_parse_factor(tokens, pos) >
    left_res := /bot_parse_primary/tokens/pos.
    pos = left_res->end.
    left := left_res->node.
    
    loop >
        tok := /bot_peek/tokens/pos.
        type := tok->type.
        is_op := (type == BOT_TOK_STAR or type == BOT_TOK_SLASH or type == BOT_TOK_PERCENT).
        >> when not is_op.
        
        pos = pos + 1.
        right_res := /bot_parse_primary/tokens/pos.
        pos = right_res->end.
        right := right_res->node.
        
        left = type | >
            5 => /bot_mul/left/right
            6 => /bot_div/left/right
            7 => /bot_mod/left/right
            _ => left
        <.
    <
    << { node: left, end: pos }.
<

#bot_parse_term(tokens, pos) >
    left_res := /bot_parse_factor/tokens/pos.
    pos = left_res->end.
    left := left_res->node.
    
    loop >
        tok := /bot_peek/tokens/pos.
        type := tok->type.
        is_op := (type == BOT_TOK_PLUS or type == BOT_TOK_MINUS).
        >> when not is_op.
        
        pos = pos + 1.
        right_res := /bot_parse_factor/tokens/pos.
        pos = right_res->end.
        right := right_res->node.
        
        left = type | >
            3 => /bot_add/left/right
            4 => /bot_sub/left/right
            _ => left
        <.
    <
    << { node: left, end: pos }.
<

#bot_parse_comp(tokens, pos) >
    left_res := /bot_parse_term/tokens/pos.
    pos = left_res->end.
    left := left_res->node.
    
    loop >
        tok := /bot_peek/tokens/pos.
        type := tok->type.
        is_op := (type ge BOT_TOK_LT and type le BOT_TOK_NE).
        >> when not is_op.
        
        pos = pos + 1.
        right_res := /bot_parse_term/tokens/pos.
        pos = right_res->end.
        right := right_res->node.
        
        left = type | >
            13 => /bot_lt_op/left/right
            14 => /bot_gt_op/left/right
            15 => /bot_le_op/left/right
            16 => /bot_ge_op/left/right
            17 => /bot_eq_op/left/right
            18 => /bot_ne_op/left/right
            _ => left
        <.
    <
    << { node: left, end: pos }.
<

#bot_parse_logic(tokens, pos) >
    left_res := /bot_parse_comp/tokens/pos.
    pos = left_res->end.
    left := left_res->node.
    
    loop >
        tok := /bot_peek/tokens/pos.
        type := tok->type.
        is_op := (type == BOT_TOK_AND or type == BOT_TOK_OR).
        >> when not is_op.
        
        pos = pos + 1.
        right_res := /bot_parse_comp/tokens/pos.
        pos = right_res->end.
        right := right_res->node.
        
        left = type | >
            19 => /bot_and_op/left/right
            20 => /bot_or_op/left/right
            _ => left
        <.
    <
    << { node: left, end: pos }.
<

#bot_parse_if_rest(tokens, pos, left) >
    cond_res := /bot_parse_logic/tokens/(pos + 1).
    else_pos := cond_res->end.
    else_tok := /bot_peek/tokens/else_pos.
    
    else_res := (else_tok->type == BOT_TOK_ELSE) | >
        1 => /bot_parse_logic/tokens/(else_pos + 1)
        0 => { node: /bot_lit/0, end: else_pos }
    <.
    
    << { node: /bot_if_expr/cond_res->node/left/else_res->node, end: else_res->end }.
<

#bot_parse_match(tokens, pos, left) >
    pos = pos + 1.
    pos = pos + 1.
    
    arms := /ds_list_create/.
    loop >
        tok := /bot_peek/tokens/pos.
        >> when tok->type == BOT_TOK_SCOPE_OUT.
        
        pattern_res := /bot_parse_primary/tokens/pos.
        pos = pattern_res->end.
        
        pos = pos + 1.
        
        body_res := /bot_parse_logic/tokens/pos.
        pos = body_res->end.
        
        /ds_list_push/arms/(/bot_match_arm/pattern_res->node/body_res->node).
    <
    
    pos = pos + 1.
    << { node: /bot_match_expr/left/arms, end: pos }.
<

#bot_parse_match_expr(tokens, pos) >
    left_res := /bot_parse_logic/tokens/pos.
    pos = left_res->end.
    left := left_res->node.
    
    tok := /bot_peek/tokens/pos.
    << tok->type | >
        36 => /bot_parse_match/tokens/pos/left
        25 => /bot_parse_if_rest/tokens/pos/left
        _ => left_res
    <.
<

#bot_parse_expr(tokens, pos) >
    << /bot_parse_match_expr/tokens/pos.
<

#bot_parse_block(tokens, pos) >
    prog := 0.
    max_iter := 500.
    iter := 0.
    
    loop >
        tok := /bot_peek/tokens/pos.
        >> when tok->type == BOT_TOK_SCOPE_OUT.
        >> when tok->type == BOT_TOK_EOF.
        >> when tok == 0.
        >> when iter ge max_iter.
        
        old_pos := pos.
        res := /bot_parse_stmt/tokens/pos.
        pos = res->end.
        
        // Safety: prevent infinite loop
        pos = pos + 1 when pos == old_pos.
        >> when pos == old_pos.
        
        prog = (prog == 0) | >
            1 => res->node
            0 => /bot_seq/prog/res->node
        <.
        
        iter = iter + 1.
    <
    
    pos = pos + 1.
    << { node: prog, end: pos }.
<

#bot_parse_loop(tokens, pos) >
    pos = pos + 1.
    pos = pos + 1.
    
    body := /bot_parse_block/tokens/pos.
    << { node: /bot_loop_stmt/body->node, end: body->end }.
<

#bot_parse_for(tokens, pos) >
    pos = pos + 1.
    
    tok := /bot_peek/tokens/pos.
    var := tok->value.
    pos = pos + 1.
    
    pos = pos + 1.
    
    start_res := /bot_parse_expr/tokens/pos.
    pos = start_res->end.
    start := start_res->node.
    
    pos = pos + 1.
    
    end_res := /bot_parse_expr/tokens/pos.
    pos = end_res->end.
    end := end_res->node.
    
    pos = pos + 1.
    
    body := /bot_parse_block/tokens/pos.
    << { node: /bot_for_stmt/var/start/end/body->node, end: body->end }.
<

#bot_parse_func(tokens, pos) >
    pos = pos + 1.
    
    tok := /bot_peek/tokens/pos.
    name := tok->value.
    pos = pos + 1.
    
    pos = pos + 1.
    
    params := /ds_list_create/.
    max_iter := 50.
    iter := 0.
    loop >
        tok = /bot_peek/tokens/pos.
        >> when tok->type == BOT_TOK_RPAREN.
        >> when tok->type == BOT_TOK_EOF.
        >> when tok == 0.
        >> when iter ge max_iter.
        
        /ds_list_push/params/tok->value when tok->value != 0.
        pos = pos + 1.
        
        tok = /bot_peek/tokens/pos.
        pos = pos + 1 when tok->type == BOT_TOK_COMMA.
        iter = iter + 1.
    <
    
    pos = pos + 1.
    pos = pos + 1.
    
    body := /bot_parse_block/tokens/pos.
    
    << { node: /bot_func_def/name/params/body->node, end: body->end }.
<

#bot_parse_call(tokens, pos) >
    pos = pos + 1.
    
    tok := /bot_peek/tokens/pos.
    name := tok->value.
    line := tok->line.
    pos = pos + 1.
    
    args := /ds_list_create/.
    loop >
        tok = /bot_peek/tokens/pos.
        >> when tok->type != BOT_TOK_SLASH.
        
        pos = pos + 1.
        
        arg_res := /bot_parse_primary/tokens/pos.
        /ds_list_push/args/arg_res->node.
        pos = arg_res->end.
    <
    
    dot := /bot_peek/tokens/pos.
    pos = pos + 1 when dot->type == BOT_TOK_DOT.
    
    << { node: /bot_func_call/name/args/line, end: pos }.
<

#bot_parse_call_expr(tokens, pos) >
    pos = pos + 1.

    tok := /bot_peek/tokens/pos.
    name := tok->value.
    line := tok->line.
    pos = pos + 1.

    args := /ds_list_create/.
    loop >
        tok = /bot_peek/tokens/pos.
        >> when tok->type != BOT_TOK_SLASH.

        pos = pos + 1.

        arg_res := /bot_parse_primary/tokens/pos.
        /ds_list_push/args/arg_res->node.
        pos = arg_res->end.
    <

    << { node: /bot_func_call/name/args/line, end: pos }.
<

#bot_parse_return(tokens, pos) >
    pos = pos + 1.
    
    res := /bot_parse_expr/tokens/pos.
    << { node: /bot_return_stmt/res->node, end: res->end }.
<

#bot_parse_stmt_assign(tokens, pos, tok) >
    name := tok->value.
    line := tok->line.
    res := /bot_parse_expr/tokens/(pos + 2).
    dot := /bot_peek/tokens/res->end.
    end := (dot->type == BOT_TOK_DOT) | >
        1 => res->end + 1
        0 => res->end
    <.
    
    << { node: /bot_decl/name/res->node/line, end: end }.
<

#bot_parse_stmt_expr(tokens, pos) >
    res := /bot_parse_expr/tokens/pos.
    dot := /bot_peek/tokens/res->end.
    end := (dot->type == BOT_TOK_DOT) | >
        1 => res->end + 1
        0 => res->end
    <.
    << { node: res->node, end: end }.
<

#bot_parse_stmt_ident(tokens, pos, tok) >
    next := /bot_peek/tokens/(pos + 1).
    << next->type | >
        8 => /bot_parse_stmt_assign/tokens/pos/tok
        _ => /bot_parse_stmt_expr/tokens/pos
    <.
<

#bot_parse_modifier(tokens, res, type) >
    pos := res->end + 1.
    cond_res := /bot_parse_expr/tokens/pos.
    
    cond := cond_res->node.
    cond = (type == BOT_TOK_UNLESS) | >
        1 => /bot_not_op/cond
        0 => cond
    <.
    
    // Get line from inner statement
    line := res->node->line.
    line = 0 when line == 0.
    
    << { node: /bot_when_stmt/res->node/cond/line, end: cond_res->end }.
<

#bot_parse_stmt(tokens, pos) >
    tok := /bot_peek/tokens/pos.
    
    res := tok->type | >
        22 => /bot_parse_loop/tokens/pos
        30 => /bot_parse_for/tokens/pos
        27 => { node: /bot_break_stmt/, end: pos + 1 }
        33 => /bot_parse_func/tokens/pos
        34 => /bot_parse_return/tokens/pos
        6 => /bot_parse_call/tokens/pos
        2 => /bot_parse_stmt_ident/tokens/pos/tok
        _ => /bot_parse_stmt_expr/tokens/pos
    <.
    
    next := /bot_peek/tokens/res->end.
    << next->type | >
        23 => /bot_parse_modifier/tokens/res/23
        24 => /bot_parse_modifier/tokens/res/24
        _ => res
    <.
<

#bot_parse_program(tokens) >
    pos := 0.
    prog := 0.
    max_iter := 1000.
    iter := 0.
    
    loop >
        tok := /bot_peek/tokens/pos.
        >> when tok->type == BOT_TOK_EOF.
        >> when tok == 0.
        >> when iter ge max_iter.
        
        old_pos := pos.
        res := /bot_parse_stmt/tokens/pos.
        pos = res->end.
        
        // Safety: if position didn't advance, skip token to prevent infinite loop
        pos = pos + 1 when pos == old_pos.
        >> when pos == old_pos.
        
        prog = (prog == 0) | >
            1 => res->node
            0 => /bot_seq/prog/res->node
        <.
        
        iter = iter + 1.
    <
    
    << prog.
<

// ============================================================================
// Environment
// ============================================================================

#bot_env_new() >
    env := /ds_object_create/0.
    /ds_set_prop/env/"__flow__"/0.
    /ds_set_prop/env/"__return__"/0.
    /ds_set_prop/env/"__parent__"/0.
    << env.
<

#bot_env_new_child(parent) >
    env := /ds_object_create/0.
    /ds_set_prop/env/"__flow__"/0.
    /ds_set_prop/env/"__return__"/0.
    /ds_set_prop/env/"__parent__"/parent.
    << env.
<

#bot_env_get_flow(env) >
    << /ds_object_get/env/"__flow__".
<

#bot_env_set_flow(env, val) >
    /ds_set_prop/env/"__flow__"/val.
    << val.
<

#bot_env_get_return(env) >
    << /ds_object_get/env/"__return__".
<

#bot_env_set_return(env, val) >
    /ds_set_prop/env/"__return__"/val.
    << val.
<

#bot_env_get(env, name) >
    val := /ds_object_get/env/name.
    parent := /ds_object_get/env/"__parent__".
    << (val == 0 and parent != 0) | >
        1 => /bot_env_get/parent/name
        0 => val
    <.
<

#bot_env_set(env, name, value) >
    /ds_set_prop/env/name/value.
    << value.
<

// ============================================================================
// Evaluator with Built-in Functions
// ============================================================================

#bot_eval_decl(node, env) >
    val := /bot_eval/node->expr/env.
    << /bot_env_set/env/node->name/val.
<

#bot_eval_assign(node, env) >
    val := /bot_eval/node->expr/env.
    << /bot_env_set/env/node->name/val.
<

#bot_eval_seq(node, env) >
    // Update line number for first statement
    bot_current_line = node->a->line when node->a->line gt 0.
    
    /bot_eval/node->a/env.
    
    // In step mode, yield after each statement
    bot_yield = 1 when bot_is_stepping == 1.
    
    flow := /bot_env_get_flow/env.
    << 0 when flow != 0.
    << 0 when bot_yield == 1.
    
    // Update line number for second statement
    bot_current_line = node->b->line when node->b->line gt 0.
    
    << /bot_eval/node->b/env.
<

#bot_eval_var(node, env) >
    << /bot_env_get/env/node->name.
<

#bot_eval_loop(node, env) >
    // In step mode, set up loop state and execute first statement only
    << /bot_enter_inf_loop_stepping/node/env when bot_is_stepping == 1.
    
    // In run mode, run the loop normally (yields on moves)
    res := 0.
    loop >
        // Update line number for loop body
        bot_current_line = node->body->line when node->body->line gt 0.
        
        res = /bot_eval/node->body/env.
        flow := /bot_env_get_flow/env.
        >> when flow == 1.
        >> when flow == 2.
        
        // Check if we should yield (from move)
        // Save loop state for resumption
        bot_in_loop = 1 when bot_yield == 1.
        bot_loop_node = node when bot_yield == 1.
        bot_loop_iter = 0 when bot_yield == 1.
        bot_loop_env = env when bot_yield == 1.
        >> when bot_yield == 1.
    <
    flow := /bot_env_get_flow/env.
    /bot_env_set_flow/env/0 when flow == 1.
    // Clear loop state if we finished normally
    bot_in_loop = 0 when bot_yield == 0.
    << res.
<

#bot_enter_inf_loop_stepping(node, env) >
    // Set up loop state for stepping
    bot_in_loop = 1.
    bot_loop_node = node.
    bot_loop_iter = 0.
    bot_loop_env = env.
    bot_loop_body_count = 0.
    bot_loop_body_idx = 0.
    
    // Flatten body and execute first statement
    /bot_step_loop_body/env.
    << 0.
<

#bot_eval_break(node, env) >
    /bot_env_set_flow/env/1.
    << 0.
<

#bot_eval_if(node, env) >
    cond := /bot_eval/node->cond/env.
    << cond | >
        1 => /bot_eval/node->then_br/env
        0 => /bot_eval/node->else_br/env
    <.
<

#bot_eval_when(node, env) >
    cond := /bot_eval/node->cond/env.
    << cond | >
        1 => /bot_eval/node->stmt/env
        0 => 0
    <.
<

#bot_eval_for(node, env) >
    start := /bot_eval/node->start/env.
    end := /bot_eval/node->end/env.
    var := node->var.
    
    // In step mode, set up loop state and execute first statement only
    << /bot_enter_for_loop_stepping/node/env/start/end/var when bot_is_stepping == 1.
    
    // In run mode, run the loop normally (yields on moves)
    i := start.
    loop >
        >> when i gt end.
        
        /bot_env_set/env/var/i.
        
        // Update line number for loop body
        bot_current_line = node->body->line when node->body->line gt 0.
        
        /bot_eval/node->body/env.
        
        flow := /bot_env_get_flow/env.
        >> when flow == 1.
        >> when flow == 2.
        
        i = i + 1.
        
        // Check if we should yield (from move)
        // Save for-loop state for resumption
        bot_in_loop = 2 when bot_yield == 1.
        bot_loop_node = node when bot_yield == 1.
        bot_loop_iter = i when bot_yield == 1.
        bot_loop_var = var when bot_yield == 1.
        bot_loop_end = end when bot_yield == 1.
        bot_loop_env = env when bot_yield == 1.
        >> when bot_yield == 1.
    <
    
    flow := /bot_env_get_flow/env.
    /bot_env_set_flow/env/0 when flow == 1.
    // Clear loop state if we finished normally
    bot_in_loop = 0 when bot_yield == 0.
    << 0.
<

#bot_enter_for_loop_stepping(node, env, start, end, var) >
    // Set up loop state for stepping
    bot_in_loop = 2.
    bot_loop_node = node.
    bot_loop_iter = start.
    bot_loop_var = var.
    bot_loop_end = end.
    bot_loop_env = env.
    bot_loop_body_count = 0.
    bot_loop_body_idx = 0.
    
    // Set loop variable
    /bot_env_set/env/var/start.
    
    // Flatten body and execute first statement
    /bot_step_loop_body/env.
    << 0.
<

#bot_eval_func(node, env) >
    func := /ds_object_create/0.
    /ds_set_prop/func/"params"/node->params.
    /ds_set_prop/func/"body"/node->body.
    /ds_set_prop/func/"env"/env.
    /bot_env_set/env/node->name/func.
    << 0.
<

#bot_eval_call(node, env) >
    name := node->name.
    args := node->args.
    
    // Check for built-in functions first
    << /bot_builtin_move/args/env when /ds_streq/name/"move".
    << /bot_builtin_get_x/args/env when /ds_streq/name/"get_x".
    << /bot_builtin_get_y/args/env when /ds_streq/name/"get_y".
    << /bot_builtin_look/args/env when /ds_streq/name/"look".
    << /bot_builtin_can_walk/args/env when /ds_streq/name/"can_walk".
    << /bot_builtin_print/args/env when /ds_streq/name/"print".
    
    // Look up user-defined function
    func := /bot_env_get/env/name.
    
    params := func->params.
    body := func->body.
    closure_env := func->env.
    
    call_env := /bot_env_new_child/closure_env.
    
    num_args := /ds_list_len/args.
    i := 0.
    loop >
        >> when i ge num_args.
        param := /ds_list_get/params/i.
        arg := /ds_list_get/args/i.
        arg_val := /bot_eval/arg/env.
        /bot_env_set/call_env/param/arg_val.
        i = i + 1.
    <
    
    res := /bot_eval/body/call_env.
    
    ret := /bot_env_get_return/call_env.
    flow := /bot_env_get_flow/call_env.
    
    << (flow == 2) | >
        1 => ret
        0 => res
    <.
<

#bot_eval_return(node, env) >
    val := /bot_eval/node->expr/env.
    /bot_env_set_return/env/val.
    /bot_env_set_flow/env/2.
    << val.
<

#bot_eval_match(node, env) >
    val := /bot_eval/node->value/env.
    arms := node->arms.
    num_arms := /ds_list_len/arms.
    
    i := 0.
    result := 0.
    found := 0.
    loop >
        >> when i ge num_arms.
        >> when found == 1.
        
        arm := /ds_list_get/arms/i.
        pattern := arm->pattern.
        
        match := pattern->tag | >
            31 => 1
            1 => (val == pattern->value)
            _ => 0
        <.
        
        result = /bot_eval/arm->body/env when match.
        found = 1 when match.
        i = i + 1.
    <
    
    << result.
<

#bot_eval_array(node, env) >
    elements := node->elements.
    len := /ds_list_len/elements.
    result := /ds_list_create/.
    
    i := 0.
    loop >
        >> when i ge len.
        elem := /ds_list_get/elements/i.
        /ds_list_push/result/(/bot_eval/elem/env).
        i = i + 1.
    <
    
    << result.
<

#bot_eval_index(node, env) >
    arr := /bot_eval/node->arr/env.
    idx := /bot_eval/node->idx/env.
    << /ds_list_get/arr/idx.
<

#bot_eval_object(node, env) >
    fields := node->fields.
    len := /ds_list_len/fields.
    obj := /ds_object_create/0.
    
    i := 0.
    loop >
        >> when i ge len.
        field := /ds_list_get/fields/i.
        key := field->key.
        val := /bot_eval/field->value/env.
        /ds_set_prop/obj/key/val.
        i = i + 1.
    <
    
    << obj.
<

#bot_eval_prop(node, env) >
    obj := /bot_eval/node->obj/env.
    key := node->key.
    << /ds_object_get/obj/key.
<

#bot_eval_lambda(node, env) >
    func := /ds_object_create/0.
    /ds_set_prop/func/"params"/node->params.
    /ds_set_prop/func/"body"/node->body.
    /ds_set_prop/func/"env"/env.
    << func.
<

#bot_eval(node, env) >
    << 0 when node == 0.
    
    << node->tag | >
        1 => (node->value)
        2 => /bot_eval_var/node/env
        3 => /bot_eval/node->a/env + /bot_eval/node->b/env
        4 => /bot_eval_decl/node/env
        5 => /bot_eval_seq/node/env
        7 => /bot_eval_assign/node/env
        8 => /bot_eval/node->a/env - /bot_eval/node->b/env
        9 => /bot_eval/node->a/env * /bot_eval/node->b/env
        10 => /ds_div/(/bot_eval/node->a/env)/(/bot_eval/node->b/env)
        11 => /ds_mod/(/bot_eval/node->a/env)/(/bot_eval/node->b/env)
        12 => (/bot_eval/node->a/env lt /bot_eval/node->b/env)
        13 => (/bot_eval/node->a/env gt /bot_eval/node->b/env)
        14 => (/bot_eval/node->a/env le /bot_eval/node->b/env)
        15 => (/bot_eval/node->a/env ge /bot_eval/node->b/env)
        16 => (/bot_eval/node->a/env == /bot_eval/node->b/env)
        17 => (/bot_eval/node->a/env != /bot_eval/node->b/env)
        18 => (/bot_eval/node->a/env and /bot_eval/node->b/env)
        19 => (/bot_eval/node->a/env or /bot_eval/node->b/env)
        20 => (not /bot_eval/node->a/env)
        21 => /bot_eval_loop/node/env
        22 => /bot_eval_break/node/env
        23 => /bot_eval_if/node/env
        24 => /bot_eval_when/node/env
        25 => /bot_eval_for/node/env
        26 => /bot_eval_func/node/env
        27 => /bot_eval_call/node/env
        28 => /bot_eval_return/node/env
        29 => /bot_eval_match/node/env
        32 => (node->value)
        33 => /bot_eval_array/node/env
        34 => /bot_eval_index/node/env
        35 => /bot_eval_object/node/env
        37 => /bot_eval_prop/node/env
        38 => /bot_eval_lambda/node/env
        _ => 0
    <.
<

// ============================================================================
// Built-in Functions for Bot Control
// ============================================================================

// /move/dx/dy - Move the bot by delta x and y
#bot_builtin_move(args, env) >
    dx := /bot_eval/(/ds_list_get/args/0)/env.
    dy := /bot_eval/(/ds_list_get/args/1)/env.
    
    result := /try_move/dx/dy.
    bot_did_move = 1 when result == 1.
    
    // Yield after a successful move to allow rendering
    bot_yield = 1 when result == 1.
    
    << result.
<

// /get_x/ - Get the bot's current X position
#bot_builtin_get_x(args, env) >
    << player_x.
<

// /get_y/ - Get the bot's current Y position
#bot_builtin_get_y(args, env) >
    << player_y.
<

// /look/dx/dy - Look at a tile relative to the bot
#bot_builtin_look(args, env) >
    dx := /bot_eval/(/ds_list_get/args/0)/env.
    dy := /bot_eval/(/ds_list_get/args/1)/env.
    
    << /get_tile/(player_x + dx)/(player_y + dy).
<

// /can_walk/dx/dy - Check if a tile is walkable
#bot_builtin_can_walk(args, env) >
    dx := /bot_eval/(/ds_list_get/args/0)/env.
    dy := /bot_eval/(/ds_list_get/args/1)/env.
    
    tile := /get_tile/(player_x + dx)/(player_y + dy).
    << /can_walk/tile.
<

// /print/value - Print a value to the message area for debugging
#bot_builtin_print(args, env) >
    val := /bot_eval/(/ds_list_get/args/0)/env.
    
    // Store in bot_print_buffer for display
    bot_print_buffer = val.
    bot_has_print = 1.
    
    << val.
<

// ============================================================================
// Bot Control Interface
// ============================================================================

#bot_compile_editor_code() >
    // Reset error state first
    bot_error = "".
    bot_has_error = 0.
    
    // Concatenate all editor lines into a single source string
    source := "".
    new_hash := 0.
    for i in 0..editor_num_lines >
        line := editor_lines[i].
        source = /ds_string_concat/source/line.
        source = /ds_string_concat/source/"\n".
        // Simple hash: sum of line lengths * (i+1)
        new_hash = new_hash + /ds_strlen/line * (i + 1).
    <
    
    // Check if code changed - reset state if so
    /bot_reset_on_change/ when new_hash != bot_code_hash.
    bot_code_hash = new_hash.
    
    // Tokenize
    tokens := /bot_tokenize/source.
    
    // Check for empty program
    token_count := /ds_list_len/tokens.
    << /bot_set_error/"Empty program" when token_count le 1.
    
    // Parse into statement list with line numbers
    /bot_parse_to_statements/tokens.
    
    // Check for parse failure
    << /bot_set_error/"Syntax error in program" when bot_stmt_count == 0.
    
    // Create fresh environment
    bot_env = /bot_env_new/.
    
    // Reset execution position
    bot_stmt_index = 0.
    bot_current_line = bot_stmt_lines[0] when bot_stmt_count gt 0.
    
    << 1.
<

#bot_parse_to_statements(tokens) >
    bot_stmt_count = 0.
    pos := 0.
    max_iter := 500.
    iter := 0.
    
    loop >
        tok := /bot_peek/tokens/pos.
        >> when tok->type == BOT_TOK_EOF.
        >> when tok == 0.
        >> when iter ge max_iter.
        
        // Get line number from first token of statement
        stmt_line := tok->line.
        
        old_pos := pos.
        res := /bot_parse_stmt/tokens/pos.
        pos = res->end.
        
        // Safety: prevent infinite loop
        pos = pos + 1 when pos == old_pos.
        >> when pos == old_pos.
        
        // Store statement and its line number
        /bot_add_statement/res->node/stmt_line when res->node != 0.
        
        iter = iter + 1.
    <
<

#bot_add_statement(node, line) >
    idx := bot_stmt_count.
    bot_statements[idx] = node.
    bot_stmt_lines[idx] = line.
    bot_stmt_count = bot_stmt_count + 1.
<

#bot_reset_on_change() >
    bot_step_count = 0.
    bot_current_line = 0 - 1.
    bot_stmt_count = 0.
    bot_stmt_index = 0.
    bot_env = 0.
    bot_is_stepping = 0.
    bot_is_running = 0.
    // Reset loop state
    bot_yield = 0.
    bot_in_loop = 0.
    bot_loop_node = 0.
    bot_loop_env = 0.
    bot_loop_body_count = 0.
    bot_loop_body_idx = 0.
<

// Call this from editor when code is modified
#bot_notify_code_changed() >
    // Only reset if actively stepping - play mode recompiles every time
    /bot_reset_on_change/ when bot_is_stepping == 1.
<

#bot_set_error(msg) >
    bot_error = msg.
    bot_has_error = 1.
    last_message = msg.
    << 0.
<

#bot_start() >
    /bot_compile_editor_code/.
    
    // Don't start if there's an error
    << 0 when bot_has_error == 1.
    
    bot_is_running = 1.
    bot_is_stepping = 0.
    bot_step_timer = 0.
    bot_step_count = 0.
    bot_stmt_index = 0.
    // Reset loop state for fresh start
    bot_yield = 0.
    bot_in_loop = 0.
    bot_loop_node = 0.
    bot_loop_env = 0.
    bot_loop_body_count = 0.
    bot_loop_body_idx = 0.
    bot_current_line = bot_stmt_lines[0] when bot_stmt_count gt 0.
    last_message = "Bot running...".
<

#bot_stop() >
    bot_is_running = 0.
    bot_is_stepping = 0.
    bot_env = 0.
    bot_step_count = 0.
    bot_stmt_count = 0.
    bot_stmt_index = 0.
    bot_current_line = 0 - 1.
    bot_code_hash = 0.
    // Reset loop state
    bot_yield = 0.
    bot_in_loop = 0.
    bot_loop_node = 0.
    bot_loop_env = 0.
    bot_loop_body_count = 0.
    bot_loop_body_idx = 0.
    last_message = "Bot stopped.".
<

#bot_step_once() >
    // Check if we need to compile (first time or code changed)
    /bot_check_recompile/.
    
    // Don't step if there's an error
    << 0 when bot_has_error == 1.
    
    // Check if we've executed all statements
    << /bot_finished_message/ when bot_stmt_index ge bot_stmt_count.
    
    bot_is_stepping = 1.
    bot_is_running = 0.
    bot_has_print = 0.
    
    // Execute one step
    /bot_do_step/.
    
    // Show print output if any
    /bot_show_print/ when bot_has_print == 1.
    last_message = "Step executed." when bot_has_print == 0.
<

#bot_show_print() >
    // Display the printed value - keep bot_has_print set for render
    last_message = "Print:".
<

// Shared core: execute one statement and handle side effects
#bot_do_step() >
    // Clear yield flag at start of each step
    bot_yield = 0.
    
    // Check if we're resuming a suspended loop
    << /bot_resume_loop/ when bot_in_loop gt 0.
    
    << 0 when bot_stmt_index ge bot_stmt_count.
    
    // Execute current statement
    /bot_execute_current_statement/.
    
    // Check if bot reached stairs
    tile := /get_tile/player_x/player_y.
    /bot_handle_stairs/ when tile == TILE_STAIRS.
    
    // Check if we just finished (only if not yielded mid-loop)
    << /bot_finished_message/ when bot_stmt_index ge bot_stmt_count and bot_in_loop == 0.
<

#bot_resume_loop() >
    // Resume a suspended loop
    bot_yield = 0.
    
    was_in_loop := bot_in_loop.
    
    // Resume infinite loop (bot_in_loop == 1)
    /bot_resume_inf_loop/ when bot_in_loop == 1.
    
    // Resume for loop (bot_in_loop == 2)
    /bot_resume_for_loop/ when bot_in_loop == 2.
    
    // Check if bot reached stairs
    tile := /get_tile/player_x/player_y.
    /bot_handle_stairs/ when tile == TILE_STAIRS.
    
    // If loop finished (bot_in_loop went from >0 to 0), advance to next statement
    bot_stmt_index = bot_stmt_index + 1 when was_in_loop gt 0 and bot_in_loop == 0.
    
    << 0.
<

#bot_resume_inf_loop() >
    node := bot_loop_node.
    env := bot_loop_env.
    
    // In step mode, execute one statement from flattened body
    << /bot_step_loop_body/env when bot_is_stepping == 1.
    
    // In run mode, execute entire body (will yield on moves)
    bot_current_line = node->body->line when node->body->line gt 0.
    /bot_eval/node->body/env.
    
    flow := /bot_env_get_flow/env.
    // Handle break
    bot_in_loop = 0 when flow == 1.
    /bot_env_set_flow/env/0 when flow == 1.
    // Handle return
    bot_in_loop = 0 when flow == 2.
    
    // If we didn't yield, loop continues next tick automatically
    // If we did yield, state is already saved
<

#bot_resume_for_loop() >
    node := bot_loop_node.
    env := bot_loop_env.
    i := bot_loop_iter.
    end := bot_loop_end.
    var := bot_loop_var.
    
    // Check if loop should end
    bot_in_loop = 0 when i gt end.
    << 0 when i gt end.
    
    // Set loop variable
    /bot_env_set/env/var/i.
    
    // In step mode, execute one statement from flattened body
    << /bot_step_loop_body/env when bot_is_stepping == 1.
    
    // In run mode, execute entire body (will yield on moves)
    bot_current_line = node->body->line when node->body->line gt 0.
    /bot_eval/node->body/env.
    
    flow := /bot_env_get_flow/env.
    // Handle break
    bot_in_loop = 0 when flow == 1.
    /bot_env_set_flow/env/0 when flow == 1.
    // Handle return
    bot_in_loop = 0 when flow == 2.
    
    // Increment for next iteration
    bot_loop_iter = i + 1.
    
    // Check if loop is done
    bot_in_loop = 0 when bot_loop_iter gt end and bot_yield == 0.
<

// Execute one statement from loop body (for step mode)
#bot_step_loop_body(env) >
    // If body not yet flattened, do it now
    /bot_flatten_loop_body/ when bot_loop_body_count == 0.
    
    // Check if we've finished the body
    << /bot_next_loop_iteration/ when bot_loop_body_idx ge bot_loop_body_count.
    
    // Get current statement in body
    stmt := bot_loop_body_stmts[bot_loop_body_idx].
    
    // Update line indicator - try to get line from node or its children
    line := /bot_get_node_line/stmt.
    bot_current_line = line when line gt 0.
    
    // Execute it
    /bot_eval/stmt/env.
    
    // Advance to next statement in body
    bot_loop_body_idx = bot_loop_body_idx + 1.
    
    // Check for flow control
    flow := /bot_env_get_flow/env.
    bot_in_loop = 0 when flow == 1.
    /bot_env_set_flow/env/0 when flow == 1.
    bot_in_loop = 0 when flow == 2.
    
    // Check if we finished the body
    << /bot_next_loop_iteration/ when bot_loop_body_idx ge bot_loop_body_count.
<

// Try to get line number from a node, checking children if needed
#bot_get_node_line(node) >
    << 0 when node == 0.
    
    // Try direct line property
    << node->line when node->line gt 0.
    
    // Try stmt child (for when nodes)
    << node->stmt->line when node->stmt != 0 and node->stmt->line gt 0.
    
    // Try a child (for binary/seq nodes)
    << node->a->line when node->a != 0 and node->a->line gt 0.
    
    << 0.
<

#bot_next_loop_iteration() >
    // Reset body position for next iteration
    bot_loop_body_idx = 0.
    
    // Increment loop counter (for for-loops)
    bot_loop_iter = bot_loop_iter + 1 when bot_in_loop == 2.
    
    // Update loop variable for next iteration (for for-loops)
    /bot_env_set/bot_loop_env/bot_loop_var/bot_loop_iter when bot_in_loop == 2.
    
    // Check if for-loop should end
    bot_in_loop = 0 when bot_in_loop == 2 and bot_loop_iter gt bot_loop_end.
    
    << 0.
<

#bot_flatten_loop_body() >
    body := bot_loop_node->body.
    bot_loop_body_count = 0.
    /bot_flatten_stmt/body.
<

#bot_flatten_stmt(node) >
    << 0 when node == 0.
    
    // If it's a seq, flatten both sides
    /bot_flatten_stmt/node->a when node->tag == BOT_TAG_SEQ.
    /bot_flatten_stmt/node->b when node->tag == BOT_TAG_SEQ.
    << 0 when node->tag == BOT_TAG_SEQ.
    
    // Otherwise, add this statement to the list
    idx := bot_loop_body_count.
    bot_loop_body_stmts[idx] = node.
    bot_loop_body_count = bot_loop_body_count + 1.
<

#bot_check_recompile() >
    // If already stepping/running, only recompile if code changed
    << 0 when bot_is_stepping == 1.
    
    // Not yet stepping, need to compile
    /bot_compile_editor_code/.
    
    // Set the current line to show first statement (before it runs)
    bot_current_line = bot_stmt_lines[0] when bot_stmt_count gt 0.
<

#bot_execute_current_statement() >
    << 0 when bot_stmt_index ge bot_stmt_count.
    
    // Get current statement
    stmt := bot_statements[bot_stmt_index].
    
    // Show indicator for THIS statement (the one about to run)
    bot_current_line = bot_stmt_lines[bot_stmt_index].
    
    // Execute it
    bot_did_move = 0.
    /bot_eval/stmt/bot_env.
    
    // Only advance if we're NOT suspended mid-loop
    // If we yielded inside a loop, don't advance - we'll resume this statement
    bot_stmt_index = bot_stmt_index + 1 when bot_in_loop == 0.
    bot_step_count = bot_step_count + 1.
<

#bot_finished_message() >
    last_message = "Program finished.".
    // Keep indicator on the last executed line - don't clear it
    // Reset state so clicking play/step starts fresh
    bot_is_running = 0.
    bot_is_stepping = 0.
    bot_stmt_index = 0.
    << 0.
<

#bot_run_tick() >
    << 0 when bot_is_running == 0.
    << 0 when bot_stmt_count == 0.
    << 0 when bot_has_error == 1.
    
    // If we've reached the end, stop (don't loop)
    << /bot_finished_message/ when bot_stmt_index ge bot_stmt_count.
    
    // Execute one step (shared with bot_step_once)
    /bot_do_step/.
<

#bot_handle_stairs() >
    last_message = "You found the stairs! Generating new dungeon...".
    dungeon_level = dungeon_level + 1.
    /generate_dungeon/.
    last_message = "Welcome to the next level!".
    /spawn_particles/player_x/player_y.
<

// ============================================================================
// Button State
// ============================================================================

BTN_PLAY := 0.
BTN_STOP := 1.
BTN_STEP := 2.

btn_hovered := 0 - 1.
btn_play_x := 0.
btn_play_y := 0.
btn_size := 32.
btn_spacing := 8.

// Speed slider
slider_x := 0.
slider_y := 0.
slider_width := 100.
slider_height := 20.
slider_pos := 0.        // 0.0 to 1.0 (logarithmic: 0=1x, 0.5=10x, 1.0=100x)
slider_dragging := 0.
speed_multiplier := 1.  // Computed from slider_pos

#set_button_positions(x, y) >
    btn_play_x = x.
    btn_play_y = y.
    // Slider positioned after the 3 buttons
    slider_x = x + (btn_size + btn_spacing) * 3 + 20.
    slider_y = y + 6.
<

#get_button_at(mx, my) >
    // Play button
    bx := btn_play_x.
    by := btn_play_y.
    << BTN_PLAY when mx ge bx and mx lt bx + btn_size and my ge by and my lt by + btn_size.
    
    // Stop button
    bx = btn_play_x + btn_size + btn_spacing.
    << BTN_STOP when mx ge bx and mx lt bx + btn_size and my ge by and my lt by + btn_size.
    
    // Step button
    bx = btn_play_x + (btn_size + btn_spacing) * 2.
    << BTN_STEP when mx ge bx and mx lt bx + btn_size and my ge by and my lt by + btn_size.
    
    << 0 - 1.
<

#update_buttons() >
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    
    btn_hovered = /get_button_at/mx/my.
    
    // Handle click
    << 0 when /input_mouse_just_pressed/ == 0.
    
    /bot_start/ when btn_hovered == BTN_PLAY and bot_is_running == 0.
    /bot_stop/ when btn_hovered == BTN_STOP.
    /bot_step_once/ when btn_hovered == BTN_STEP.
<

#draw_buttons() >
    // Position buttons above editor
    bx := btn_play_x.
    by := btn_play_y.
    
    // Play button (triangle)
    play_hover := (btn_hovered == BTN_PLAY).
    play_active := bot_is_running.
    play_r := 60. play_g := 180. play_b := 80.
    play_r = 80 when play_hover == 1. play_g = 220 when play_hover == 1. play_b = 100 when play_hover == 1.
    play_r = 100 when play_active == 1. play_g = 255 when play_active == 1. play_b = 120 when play_active == 1.
    
    // Draw active border for play button
    /draw_rect/(bx - 2)/(by - 2)/(btn_size + 4)/(btn_size + 4)/80/220/100/255 when play_active == 1.
    /draw_rect/bx/by/btn_size/btn_size/30/35/40/255.
    /draw_play_icon/(bx + 8)/(by + 6)/play_r/play_g/play_b.
    
    // Stop button (square)
    bx = btn_play_x + btn_size + btn_spacing.
    stop_hover := (btn_hovered == BTN_STOP).
    stop_r := 180. stop_g := 60. stop_b := 60.
    stop_r = 220 when stop_hover == 1. stop_g = 80 when stop_hover == 1. stop_b = 80 when stop_hover == 1.
    
    /draw_rect/bx/by/btn_size/btn_size/30/35/40/255.
    /draw_stop_icon/(bx + 10)/(by + 10)/stop_r/stop_g/stop_b.
    
    // Step button (step arrow)
    bx = btn_play_x + (btn_size + btn_spacing) * 2.
    step_hover := (btn_hovered == BTN_STEP).
    step_active := bot_is_stepping.
    step_r := 80. step_g := 140. step_b := 200.
    step_r = 100 when step_hover == 1. step_g = 180 when step_hover == 1. step_b = 240 when step_hover == 1.
    step_r = 120 when step_active == 1. step_g = 200 when step_active == 1. step_b = 255 when step_active == 1.
    
    // Draw active border for step button
    /draw_rect/(bx - 2)/(by - 2)/(btn_size + 4)/(btn_size + 4)/100/180/240/255 when step_active == 1.
    /draw_rect/bx/by/btn_size/btn_size/30/35/40/255.
    /draw_step_icon/(bx + 6)/(by + 6)/step_r/step_g/step_b.
<

#draw_play_icon(x, y, r, g, b) >
    // Draw triangle pointing right (play icon)
    // Using rectangles to approximate triangle shape
    /draw_rect/(x + 0)/(y + 8)/4/4/r/g/b/255.
    /draw_rect/(x + 2)/(y + 6)/4/8/r/g/b/255.
    /draw_rect/(x + 4)/(y + 4)/4/12/r/g/b/255.
    /draw_rect/(x + 6)/(y + 6)/4/8/r/g/b/255.
    /draw_rect/(x + 8)/(y + 8)/4/4/r/g/b/255.
    /draw_rect/(x + 10)/(y + 9)/4/2/r/g/b/255.
<

#draw_stop_icon(x, y, r, g, b) >
    // Draw square (stop icon)
    /draw_rect/x/y/12/12/r/g/b/255.
<

#draw_step_icon(x, y, r, g, b) >
    // Draw step-forward icon (bar + triangle)
    // Vertical bar
    /draw_rect/x/y/3/20/r/g/b/255.
    // Triangle (simplified as rectangles)
    /draw_rect/(x + 6)/(y + 8)/3/4/r/g/b/255.
    /draw_rect/(x + 8)/(y + 6)/3/8/r/g/b/255.
    /draw_rect/(x + 10)/(y + 4)/3/12/r/g/b/255.
    /draw_rect/(x + 12)/(y + 6)/3/8/r/g/b/255.
    /draw_rect/(x + 14)/(y + 8)/3/4/r/g/b/255.
<

// ============================================================================
// Speed Slider
// ============================================================================

#draw_slider() >
    sx := slider_x.
    sy := slider_y.
    sw := slider_width.
    sh := slider_height.
    
    // Background track
    /draw_rect/sx/sy/sw/sh/40/45/50/255.
    
    // Filled portion (up to slider position)
    fill_w := slider_pos * sw / 100.
    /draw_rect/sx/sy/fill_w/sh/60/120/180/255.
    
    // Handle
    handle_x := sx + fill_w - 4.
    handle_x = sx when handle_x lt sx.
    /draw_rect/handle_x/(sy - 2)/ 8/(sh + 4)/200/200/220/255.
    
    // Labels: 1x, 1000x
    /text_draw/(sx - 15)/(sy + 4)/10/150/150/150/"1x".
    /text_draw/(sx + sw + 5)/(sy + 4)/10/150/150/150/"1000x".
    
    // Current speed indicator
    /text_draw_int/(sx + sw / 2 - 10)/(sy - 15)/12/255/220/80/speed_multiplier.
    /text_draw/(sx + sw / 2 + 15)/(sy - 15)/12/255/220/80/"x".
<

#update_slider() >
    mx := /input_mouse_x/.
    my := /input_mouse_y/.
    down := /input_mouse_down/.
    just_pressed := /input_mouse_just_pressed/.
    
    // Check if mouse is over slider
    in_slider := mx ge slider_x and mx lt slider_x + slider_width and my ge slider_y - 5 and my lt slider_y + slider_height + 5.
    
    // Start dragging
    slider_dragging = 1 when just_pressed == 1 and in_slider == 1.
    
    // Stop dragging
    slider_dragging = 0 when down == 0.
    
    // Update position while dragging
    /update_slider_pos/mx when slider_dragging == 1.
<

#update_slider_pos(mx) >
    // Calculate position (0-100)
    pos := (mx - slider_x) * 100 / slider_width.
    pos = 0 when pos lt 0.
    pos = 100 when pos gt 100.
    slider_pos = pos.
    
    // Calculate speed multiplier (logarithmic: 1x to 1000x)
    // pos=0 -> 1x, pos=50 -> ~32x, pos=100 -> 1000x
    // Using: speed = 10^(pos * 3 / 100) = 1 to 1000
    // Approximate with cubic: speed = 1 + (pos^3 * 999) / 1000000
    speed_multiplier = 1 + (pos * pos * pos * 999) / 1000000.
    
    // Update bot step delay: base delay / speed
    // Base delay is 500ms at 1x
    bot_step_delay = 500 / speed_multiplier.
    bot_step_delay = 1 when bot_step_delay lt 1.
<

