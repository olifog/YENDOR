// dungeon.nh - Dungeon map data and procedural generation
// ============================================================================
// Map Constants
// ============================================================================

MAP_WIDTH := 50.
MAP_HEIGHT := 20.

// Tile types
TILE_EMPTY := 0.
TILE_FLOOR := 1.
TILE_WALL_H := 2.
TILE_WALL_V := 3.
TILE_CORRIDOR := 4.
TILE_DOOR := 5.
TILE_STAIRS := 6.
TILE_GOLD := 7.

// ============================================================================
// Dungeon Map
// ============================================================================

dungeon := [].

// ============================================================================
// Room Storage
// ============================================================================

// Room data: each room has x, y, w, h, center_x, center_y
room_x := [].
room_y := [].
room_w := [].
room_h := [].
room_cx := [].
room_cy := [].
room_count := 0.

// ============================================================================
// Dungeon Access
// ============================================================================

#get_tile(x, y) >
    << TILE_EMPTY when x lt 0.
    << TILE_EMPTY when y lt 0.
    << TILE_EMPTY when x ge MAP_WIDTH.
    << TILE_EMPTY when y ge MAP_HEIGHT.
    idx := y * MAP_WIDTH + x.
    << dungeon[idx].
<

#set_tile(x, y, val) >
    << 0 when x lt 0.
    << 0 when y lt 0.
    << 0 when x ge MAP_WIDTH.
    << 0 when y ge MAP_HEIGHT.
    idx := y * MAP_WIDTH + x.
    dungeon[idx] = val.
<

// ============================================================================
// Room Drawing
// ============================================================================

#make_room(rx, ry, rw, rh) >
    // Draw floor
    for dy in 1..(rh - 1) >
        for dx in 1..(rw - 1) >
            /set_tile/(rx + dx)/(ry + dy)/TILE_FLOOR.
        <
    <
    
    // Draw horizontal walls (only on empty tiles)
    for dx in 0..rw >
        t1 := /get_tile/(rx + dx)/ry.
        /set_tile/(rx + dx)/ry/TILE_WALL_H when t1 == TILE_EMPTY.
        t2 := /get_tile/(rx + dx)/(ry + rh - 1).
        /set_tile/(rx + dx)/(ry + rh - 1)/TILE_WALL_H when t2 == TILE_EMPTY.
    <
    
    // Draw vertical walls (only on empty tiles)
    for dy in 1..(rh - 1) >
        t1 := /get_tile/rx/(ry + dy).
        /set_tile/rx/(ry + dy)/TILE_WALL_V when t1 == TILE_EMPTY.
        t2 := /get_tile/(rx + rw - 1)/(ry + dy).
        /set_tile/(rx + rw - 1)/(ry + dy)/TILE_WALL_V when t2 == TILE_EMPTY.
    <
<

// ============================================================================
// Overlap Detection
// ============================================================================

#check_room_overlap(rx, ry, rw, rh) >
    // Check if room overlaps any existing room (with 1 tile padding)
    for i in 0..room_count >
        ox := room_x[i].
        oy := room_y[i].
        ow := room_w[i].
        oh := room_h[i].
        
        // Check overlap with padding
        left1 := rx - 1.
        right1 := rx + rw + 1.
        top1 := ry - 1.
        bottom1 := ry + rh + 1.
        
        left2 := ox.
        right2 := ox + ow.
        top2 := oy.
        bottom2 := oy + oh.
        
        // Overlap if rectangles intersect
        no_overlap := 0.
        no_overlap = 1 when right1 le left2.
        no_overlap = 1 when left1 ge right2.
        no_overlap = 1 when bottom1 le top2.
        no_overlap = 1 when top1 ge bottom2.
        
        << 1 when no_overlap == 0. // Overlap detected
    <
    << 0. // No overlap
<

// ============================================================================
// Drunken Walk Corridor Drawing (NetHack-style)
// ============================================================================

#is_wall_tile(tile) >
    << 1 when tile == TILE_WALL_H.
    << 1 when tile == TILE_WALL_V.
    << 0.
<

#can_place_corridor(x, y) >
    // Check if we can place a corridor tile here
    tile := /get_tile/x/y.
    << 1 when tile == TILE_EMPTY.
    << 1 when tile == TILE_CORRIDOR. // Can overlap existing corridors
    << 0.
<

#force_door_if_wall(x, y) >
    // If tile at x,y is a wall, turn it into a door
    // Check bounds first  
    << 0 when x lt 0.
    << 0 when y lt 0.
    << 0 when x ge MAP_WIDTH.
    << 0 when y ge MAP_HEIGHT.
    
    tile := /get_tile/x/y.
    << 0 when /is_wall_tile/tile == 0. // Not a wall, nothing to do
    
    // Turn this wall into a door
    /set_tile/x/y/TILE_DOOR.
    
    // Check if this door connects to any floor (i.e., opens into a room)
    // If not, we're at a corner and need to extend the door to an adjacent wall
    /extend_door_if_corner/x/y.
    
    << 0.
<

#extend_door_if_corner(x, y) >
    // After placing a door, check if it has adjacent floor
    // If not, it's a corner - also make an adjacent wall into a door
    
    left_tile := /get_tile/(x-1)/y.
    right_tile := /get_tile/(x+1)/y.
    up_tile := /get_tile/x/(y-1).
    down_tile := /get_tile/x/(y+1).
    
    // Check for adjacent floor
    has_floor := 0.
    has_floor = 1 when left_tile == TILE_FLOOR.
    has_floor = 1 when right_tile == TILE_FLOOR.
    has_floor = 1 when up_tile == TILE_FLOOR.
    has_floor = 1 when down_tile == TILE_FLOOR.
    
    << 0 when has_floor == 1. // Already connects to room, we're good
    
    // No adjacent floor - this is a corner. Open an adjacent wall.
    // Pick the first wall we find and make it a door
    made_door := 0.
    
    // Check left
    is_left_wall := /is_wall_tile/left_tile.
    /set_tile/(x-1)/y/TILE_DOOR when is_left_wall == 1 and made_door == 0.
    made_door = 1 when is_left_wall == 1.
    
    // Check right  
    is_right_wall := /is_wall_tile/right_tile.
    /set_tile/(x+1)/y/TILE_DOOR when is_right_wall == 1 and made_door == 0.
    made_door = 1 when is_right_wall == 1 and made_door == 0.
    
    // Check up
    is_up_wall := /is_wall_tile/up_tile.
    /set_tile/x/(y-1)/TILE_DOOR when is_up_wall == 1 and made_door == 0.
    made_door = 1 when is_up_wall == 1 and made_door == 0.
    
    // Check down
    is_down_wall := /is_wall_tile/down_tile.
    /set_tile/x/(y+1)/TILE_DOOR when is_down_wall == 1 and made_door == 0.
    
    << 0.
<

#create_adjacent_doors(cx, cy) >
    // Force doors on any adjacent walls - ensures corridor always connects
    /force_door_if_wall/(cx - 1)/cy.
    /force_door_if_wall/(cx + 1)/cy.
    /force_door_if_wall/cx/(cy - 1).
    /force_door_if_wall/cx/(cy + 1).
    << 0.
<

#dig_drunk_corridor(x1, y1, x2, y2, door1_x, door1_y, door2_x, door2_y) >
    // Connect two points with a "drunken walk" corridor
    // x1,y1 and x2,y2 are one tile OUTSIDE the room walls
    // door1/door2 are ON the walls
    
    // First, create doors at both walls
    /set_tile/door1_x/door1_y/TILE_DOOR.
    /set_tile/door2_x/door2_y/TILE_DOOR.
    
    // Start digging from x1,y1
    cx := x1.
    cy := y1.
    
    // Place first corridor tile
    /set_tile/cx/cy/TILE_CORRIDOR when /can_place_corridor/cx/cy == 1.
    
    // Max steps to prevent infinite loops
    max_steps := (MAP_WIDTH + MAP_HEIGHT) * 4.
    steps := 0.
    
    loop when steps lt max_steps >
        // Check if we've reached the destination
        at_dest := 0.
        at_dest = 1 when cx == x2 and cy == y2.
        >> when at_dest == 1.
        
        // Calculate direction to target
        dx := 0.
        dx = 1 when x2 gt cx.
        dx = 0 - 1 when x2 lt cx.
        
        dy := 0.
        dy = 1 when y2 gt cy.
        dy = 0 - 1 when y2 lt cy.
        
        // Calculate distances
        dist_x := x2 - cx.
        dist_x = 0 - dist_x when dist_x lt 0.
        dist_y := y2 - cy.
        dist_y = 0 - dist_y when dist_y lt 0.
        
        // Roll for behavior: 0-84 = toward target, 85-96 = deviate, 97-99 = wobble
        roll := /rng_int/100.
        
        move_x := 0.
        move_y := 0.
        
        // Decide axis: prefer the one with more distance
        prefer_x := 0.
        prefer_x = 1 when dist_x gt dist_y.
        // If equal, random choice
        rand_axis := /rng_int/2.
        prefer_x = rand_axis when dist_x == dist_y and dist_x gt 0.
        
        // If only one axis left, must go that way
        must_x := 0.
        must_y := 0.
        must_x = 1 when dist_y == 0 and dist_x gt 0.
        must_y = 1 when dist_x == 0 and dist_y gt 0.
        
        // Normal movement toward target (85%)
        normal := 0.
        normal = 1 when roll lt 85.
        
        // Deviation: perpendicular (12%)
        deviate := 0.
        deviate = 1 when roll ge 85 and roll lt 97.
        
        // Wobble: random perpendicular (3%)
        wobble := 0.
        wobble = 1 when roll ge 97.
        
        // Handle must cases first
        move_x = dx when must_x == 1.
        move_y = dy when must_y == 1.
        
        // Normal movement (if not must case)
        no_must := 1 - must_x - must_y.
        no_must = 0 when no_must lt 0.
        
        // Normal: move along preferred axis
        move_x = dx when normal == 1 and prefer_x == 1 and no_must == 1.
        move_y = dy when normal == 1 and prefer_x == 0 and no_must == 1.
        
        // Deviation: move along non-preferred axis
        move_y = dy when deviate == 1 and prefer_x == 1 and dist_y gt 0 and no_must == 1.
        move_x = dx when deviate == 1 and prefer_x == 0 and dist_x gt 0 and no_must == 1.
        // Fall back to preferred if perpendicular has no distance
        move_x = dx when deviate == 1 and prefer_x == 1 and dist_y == 0 and no_must == 1.
        move_y = dy when deviate == 1 and prefer_x == 0 and dist_x == 0 and no_must == 1.
        
        // Wobble: perpendicular jog
        wobble_dir := /rng_int/2.
        move_y = 1 when wobble == 1 and wobble_dir == 0 and prefer_x == 1 and no_must == 1 and dist_y gt 0.
        move_y = 0 - 1 when wobble == 1 and wobble_dir == 1 and prefer_x == 1 and no_must == 1 and dist_y gt 0.
        move_x = 1 when wobble == 1 and wobble_dir == 0 and prefer_x == 0 and no_must == 1 and dist_x gt 0.
        move_x = 0 - 1 when wobble == 1 and wobble_dir == 1 and prefer_x == 0 and no_must == 1 and dist_x gt 0.
        // Fall back if wobble can't go perpendicular
        move_x = dx when wobble == 1 and prefer_x == 1 and dist_y == 0 and no_must == 1.
        move_y = dy when wobble == 1 and prefer_x == 0 and dist_x == 0 and no_must == 1.
        
        // Try primary move
        new_x := cx + move_x.
        new_y := cy + move_y.
        
        // Check if move is valid
        valid := 1.
        valid = 0 when new_x lt 0.
        valid = 0 when new_y lt 0.
        valid = 0 when new_x ge MAP_WIDTH.
        valid = 0 when new_y ge MAP_HEIGHT.
        
        // Check new tile - can we place corridor there?
        new_tile := /get_tile/new_x/new_y.
        is_wall := /is_wall_tile/new_tile.
        valid = 0 when is_wall == 1.
        
        // If valid, move and place corridor
        moved := 0.
        cx = new_x when valid == 1.
        cy = new_y when valid == 1.
        moved = valid.
        /set_tile/cx/cy/TILE_CORRIDOR when moved == 1 and /can_place_corridor/cx/cy == 1.
        
        // If not valid, try direct move toward target
        try_direct := 0.
        try_direct = 1 when moved == 0 and dx != 0.
        
        direct_x := cx + dx.
        direct_y := cy.
        direct_tile := /get_tile/direct_x/direct_y.
        direct_ok := 0.
        direct_ok = 1 when /is_wall_tile/direct_tile == 0.
        direct_ok = 0 when direct_x lt 0.
        direct_ok = 0 when direct_x ge MAP_WIDTH.
        
        cx = direct_x when try_direct == 1 and direct_ok == 1.
        moved = 1 when try_direct == 1 and direct_ok == 1.
        /set_tile/cx/cy/TILE_CORRIDOR when try_direct == 1 and direct_ok == 1 and /can_place_corridor/cx/cy == 1.
        
        // If still not moved, try vertical direct
        try_vert := 0.
        try_vert = 1 when moved == 0 and dy != 0.
        
        vert_x := cx.
        vert_y := cy + dy.
        vert_tile := /get_tile/vert_x/vert_y.
        vert_ok := 0.
        vert_ok = 1 when /is_wall_tile/vert_tile == 0.
        vert_ok = 0 when vert_y lt 0.
        vert_ok = 0 when vert_y ge MAP_HEIGHT.
        
        cy = vert_y when try_vert == 1 and vert_ok == 1.
        moved = 1 when try_vert == 1 and vert_ok == 1.
        /set_tile/cx/cy/TILE_CORRIDOR when try_vert == 1 and vert_ok == 1 and /can_place_corridor/cx/cy == 1.
        
        steps = steps + 1.
    <
    
    // Ensure final tile at destination is placed
    /set_tile/x2/y2/TILE_CORRIDOR when /can_place_corridor/x2/y2 == 1.
    
    // FALLBACK: Force doors on any walls adjacent to where corridor ends
    // This handles cases where the drunken walk diverged from the planned path
    /create_adjacent_doors/cx/cy.
<

// ============================================================================
// Room Edge Point Calculation
// ============================================================================

#get_room_edge_point(room_idx, target_x, target_y) >
    // Get a point on the room's wall facing toward target
    // Returns packed value: y * 1000 + x
    // The point is OUTSIDE the room (on the wall tile)
    
    rx := room_x[room_idx].
    ry := room_y[room_idx].
    rw := room_w[room_idx].
    rh := room_h[room_idx].
    cx := room_cx[room_idx].
    cy := room_cy[room_idx].
    
    // Determine which wall to use based on target direction
    diff_x := target_x - cx.
    diff_y := target_y - cy.
    
    abs_dx := diff_x.
    abs_dx = 0 - diff_x when diff_x lt 0.
    abs_dy := diff_y.
    abs_dy = 0 - diff_y when diff_y lt 0.
    
    // Pick wall based on primary direction
    // 0 = top, 1 = bottom, 2 = left, 3 = right
    wall := 0.
    
    // Prefer horizontal movement if dx > dy
    prefer_horiz := 0.
    prefer_horiz = 1 when abs_dx gt abs_dy.
    
    // Right wall if target is to the right
    wall = 3 when prefer_horiz == 1 and diff_x gt 0.
    // Left wall if target is to the left
    wall = 2 when prefer_horiz == 1 and diff_x lt 0.
    // Bottom wall if target is below
    wall = 1 when prefer_horiz == 0 and diff_y gt 0.
    // Top wall if target is above
    wall = 0 when prefer_horiz == 0 and diff_y le 0.
    
    // Get random point along that wall (interior columns/rows only)
    edge_x := 0.
    edge_y := 0.
    
    int_w := rw - 2.
    int_h := rh - 2.
    int_w = 1 when int_w lt 1.
    int_h = 1 when int_h lt 1.
    
    // Top wall - corridor starts one tile above top wall
    edge_x = rx + 1 + /rng_int/int_w when wall == 0.
    edge_y = ry - 1 when wall == 0.
    
    // Bottom wall - corridor starts one tile below bottom wall
    edge_x = rx + 1 + /rng_int/int_w when wall == 1.
    edge_y = ry + rh when wall == 1.
    
    // Left wall - corridor starts one tile left of left wall
    edge_x = rx - 1 when wall == 2.
    edge_y = ry + 1 + /rng_int/int_h when wall == 2.
    
    // Right wall - corridor starts one tile right of right wall
    edge_x = rx + rw when wall == 3.
    edge_y = ry + 1 + /rng_int/int_h when wall == 3.
    
    << edge_y * 1000 + edge_x.
<

#get_door_position(room_idx, edge_x, edge_y) >
    // Given an edge point outside the room, find the wall tile for the door
    // Returns packed value: y * 1000 + x
    
    rx := room_x[room_idx].
    ry := room_y[room_idx].
    rw := room_w[room_idx].
    rh := room_h[room_idx].
    
    door_x := edge_x.
    door_y := edge_y.
    
    // If edge is above room, door is on top wall
    door_y = ry when edge_y lt ry.
    // If edge is below room, door is on bottom wall
    door_y = ry + rh - 1 when edge_y ge ry + rh.
    // If edge is left of room, door is on left wall
    door_x = rx when edge_x lt rx.
    // If edge is right of room, door is on right wall
    door_x = rx + rw - 1 when edge_x ge rx + rw.
    
    << door_y * 1000 + door_x.
<

// ============================================================================
// Random Room Placement
// ============================================================================

#try_place_random_room() >
    // Generate random room dimensions
    size_range := dng_max_room_size - dng_min_room_size + 1.
    rw := /rng_int/size_range + dng_min_room_size + 2.  // +2 for walls
    rh := /rng_int/size_range + dng_min_room_size + 2.
    
    // Generate random position (leaving border for walls and corridors)
    max_x := MAP_WIDTH - rw - 2.
    max_y := MAP_HEIGHT - rh - 2.
    
    << 0 when max_x lt 2.
    << 0 when max_y lt 2.
    
    rx := /rng_int/max_x + 1.
    ry := /rng_int/max_y + 1.
    
    // Check for overlaps
    overlaps := /check_room_overlap/rx/ry/rw/rh.
    << 0 when overlaps == 1.
    
    // Place the room
    /make_room/rx/ry/rw/rh.
    
    // Store room data
    idx := room_count.
    room_x[idx] = rx.
    room_y[idx] = ry.
    room_w[idx] = rw.
    room_h[idx] = rh.
    room_cx[idx] = rx + rw / 2.
    room_cy[idx] = ry + rh / 2.
    room_count = room_count + 1.
    
    << 1.
<

// ============================================================================
// Connect Rooms with Corridors (Nearest-Neighbor / Prim's Algorithm)
// ============================================================================

// Track which rooms are connected
room_connected := [].

#get_room_distance(room_a, room_b) >
    // Calculate Manhattan distance between room centers
    ax := room_cx[room_a].
    ay := room_cy[room_a].
    bx := room_cx[room_b].
    by := room_cy[room_b].
    
    dx := bx - ax.
    dx = 0 - dx when dx lt 0.
    dy := by - ay.
    dy = 0 - dy when dy lt 0.
    
    << dx + dy.
<

#find_nearest_connected_room(room_idx) >
    // Find the nearest room to room_idx that is already connected
    // Returns the index of that room, or -1 if none found
    
    best_room := -1.
    best_dist := 9999.
    
    for i in 0..room_count >
        // Skip self
        >< when i == room_idx.
        
        // Skip unconnected rooms
        is_conn := room_connected[i].
        >< when is_conn == 0.
        
        // Calculate distance
        dist := /get_room_distance/room_idx/i.
        
        // Update best if closer
        is_better := 0.
        is_better = 1 when dist lt best_dist.
        
        best_room = i when is_better == 1.
        best_dist = dist when is_better == 1.
    <
    
    << best_room.
<

#find_nearest_unconnected_room() >
    // Find the unconnected room that is closest to any connected room
    // Returns packed value: nearest_connected * 1000 + unconnected_room
    // Or -1 if no unconnected rooms remain
    
    best_unconnected := -1.
    best_connected := -1.
    best_dist := 9999.
    
    for u in 0..room_count >
        // Skip if already connected
        u_conn := room_connected[u].
        >< when u_conn == 1.
        
        // Find the closest connected room to this unconnected room
        for c in 0..room_count >
            // Skip if not connected
            c_conn := room_connected[c].
            >< when c_conn == 0.
            
            // Calculate distance
            dist := /get_room_distance/u/c.
            
            // Update if this is the best pair so far
            is_better := 0.
            is_better = 1 when dist lt best_dist.
            
            best_unconnected = u when is_better == 1.
            best_connected = c when is_better == 1.
            best_dist = dist when is_better == 1.
        <
    <
    
    << -1 when best_unconnected == -1.
    << best_connected * 1000 + best_unconnected.
<

#connect_two_rooms(room_a, room_b) >
    // Connect room_a to room_b with a corridor
    
    // Get centers for direction calculation
    cx1 := room_cx[room_a].
    cy1 := room_cy[room_a].
    cx2 := room_cx[room_b].
    cy2 := room_cy[room_b].
    
    // Get edge points on each room's wall facing the other
    packed1 := /get_room_edge_point/room_a/cx2/cy2.
    packed2 := /get_room_edge_point/room_b/cx1/cy1.
    
    // Unpack corridor start/end coordinates (outside the walls)
    x1 := packed1 % 1000.
    y1 := packed1 / 1000.
    x2 := packed2 % 1000.
    y2 := packed2 / 1000.
    
    // Get door positions (on the walls)
    door1_packed := /get_door_position/room_a/x1/y1.
    door2_packed := /get_door_position/room_b/x2/y2.
    
    door1_x := door1_packed % 1000.
    door1_y := door1_packed / 1000.
    door2_x := door2_packed % 1000.
    door2_y := door2_packed / 1000.
    
    // Dig drunken walk corridor (NetHack-style)
    /dig_drunk_corridor/x1/y1/x2/y2/door1_x/door1_y/door2_x/door2_y.
<

#connect_rooms() >
    // Use Prim's algorithm to connect rooms by nearest neighbor
    // This ensures corridors don't skip over intermediate rooms
    
    << 0 when room_count lt 2.
    
    // Initialize: all rooms unconnected
    for i in 0..room_count >
        room_connected[i] = 0.
    <
    
    // Start with room 0 as connected
    room_connected[0] = 1.
    connected_count := 1.
    
    // Keep connecting until all rooms are connected
    loop when connected_count lt room_count >
        // Find the unconnected room closest to any connected room
        packed := /find_nearest_unconnected_room/.
        
        // Safety: break if no room found (shouldn't happen)
        >> when packed == -1.
        
        // Unpack the result
        conn_room := packed / 1000.
        unconn_room := packed % 1000.
        
        // Connect them
        /connect_two_rooms/conn_room/unconn_room.
        
        // Mark the unconnected room as now connected
        room_connected[unconn_room] = 1.
        connected_count = connected_count + 1.
    <
    
    // Optional: 70% chance to add one extra corridor for variety (creates loops)
    extra := /rng_int/100.
    add_extra := 0.
    add_extra = 1 when extra lt 70 and room_count gt 2.
    
    /add_extra_corridor/ when add_extra == 1.
<

#add_extra_corridor() >
    // Connect two random rooms that aren't already likely connected
    // Pick first room randomly
    room_a := /rng_int/room_count.
    
    // Find the room that is FURTHEST from room_a (most likely to create interesting loop)
    furthest := -1.
    furthest_dist := 0.
    
    for i in 0..room_count >
        >< when i == room_a.
        dist := /get_room_distance/room_a/i.
        is_further := 0.
        is_further = 1 when dist gt furthest_dist.
        furthest = i when is_further == 1.
        furthest_dist = dist when is_further == 1.
    <
    
    // Connect to furthest room (creates interesting shortcuts across the dungeon)
    /connect_two_rooms/room_a/furthest when furthest != -1.
<

// ============================================================================
// Stairs Placement
// ============================================================================

#place_stairs() >
    // At game start (no random stairs upgrade), place stairs at top-right of first room
    use_fixed := 0.
    use_fixed = 1 when dng_stairs_random == 0.
    
    // Fixed placement: top-right corner of first room's interior
    trx := room_x[0].
    try := room_y[0].
    trw := room_w[0].
    trh := room_h[0].
    
    // Top-right of interior: (rx + w - 2, ry + 1)
    sx := trx + trw - 2.
    sy := try + 1.
    /set_tile/sx/sy/TILE_STAIRS when use_fixed == 1.
    << 0 when use_fixed == 1.
    
    // Random placement: choose target room for stairs (prefer not player's room)
    player_room := 0.
    
    // Find which room player is in
    for i in 0..room_count >
        rx := room_x[i].
        ry := room_y[i].
        rw := room_w[i].
        rh := room_h[i].
        
        in_x := 0.
        in_x = 1 when player_x ge rx and player_x lt rx + rw.
        in_y := 0.
        in_y = 1 when player_y ge ry and player_y lt ry + rh.
        
        player_room = i when in_x == 1 and in_y == 1.
    <
    
    // Pick stairs room (different from player if possible)
    stairs_room := /rng_int/room_count.
    
    // If only 1 room, stairs must be with player
    // If multiple rooms, try to pick different one
    tries := 0.
    loop when stairs_room == player_room and room_count gt 1 and tries lt 10 >
        stairs_room = /rng_int/room_count.
        tries = tries + 1.
    <
    
    // Get stairs room bounds
    srx := room_x[stairs_room].
    sry := room_y[stairs_room].
    srw := room_w[stairs_room].
    srh := room_h[stairs_room].
    
    // Place stairs at random position in room interior
    int_w := srw - 2.
    int_h := srh - 2.
    
    sx = srx + 1 + /rng_int/int_w.
    sy = sry + 1 + /rng_int/int_h.
    
    // Make sure not on player
    tries = 0.
    loop when sx == player_x and sy == player_y and tries lt 20 >
        sx = srx + 1 + /rng_int/int_w.
        sy = sry + 1 + /rng_int/int_h.
        tries = tries + 1.
    <
    
    /set_tile/sx/sy/TILE_STAIRS.
<

// ============================================================================
// Gold Spawning
// ============================================================================

#spawn_gold_piles() >
    << 0 when dng_gold_enabled == 0.
    
    // Spawn gold in rooms - one pile per room, max 3
    gold_count := room_count.
    gold_count = 1 when gold_count lt 1.
    gold_count = 3 when gold_count gt 3.
    
    for k in 0..gold_count >
        // Pick random room
        target := /rng_int/room_count.
        
        // Get room bounds
        trx := room_x[target].
        try := room_y[target].
        trw := room_w[target].
        trh := room_h[target].
        
        // Random position in interior
        int_w := trw - 2.
        int_h := trh - 2.
        
        gx := trx + 1 + /rng_int/int_w.
        gy := try + 1 + /rng_int/int_h.
        
        // Only place on floor (not on player, stairs, other gold)
        tile := /get_tile/gx/gy.
        /set_tile/gx/gy/TILE_GOLD when tile == TILE_FLOOR.
    <
<

// ============================================================================
// Main Dungeon Generation
// ============================================================================

#generate_dungeon() >
    // Generate new seed and save it
    dungeon_seed = /time_ms/.
    /rng_seed/dungeon_seed.
    /do_generate_dungeon/.
<

#regenerate_dungeon() >
    // Regenerate with same seed (for retry)
    /rng_seed/dungeon_seed.
    /do_generate_dungeon/.
<

#do_generate_dungeon() >
    // Recalculate params from tech tree
    /recalc_dungeon_params/.
    
    // Clear map
    size := MAP_WIDTH * MAP_HEIGHT.
    for i in 0..size >
        dungeon[i] = TILE_EMPTY.
    <
    
    // Reset room data
    room_count = 0.
    
    // Phase 1: Place rooms randomly
    target_rooms := dng_max_rooms.
    attempts := 0.
    max_attempts := target_rooms * 50.  // Allow many retries
    
    loop when room_count lt target_rooms >
        << 0 when attempts ge max_attempts.
        
        success := /try_place_random_room/.
        attempts = attempts + 1.
    <
    
    // Ensure at least 1 room
    placed := 0.
    loop when room_count == 0 and placed == 0 >
        // Force place a room in center if all attempts failed
        rw := dng_min_room_size + 2.
        rh := dng_min_room_size + 2.
        rx := MAP_WIDTH / 2 - rw / 2.
        ry := MAP_HEIGHT / 2 - rh / 2.
        
        /make_room/rx/ry/rw/rh.
        room_x[0] = rx.
        room_y[0] = ry.
        room_w[0] = rw.
        room_h[0] = rh.
        room_cx[0] = rx + rw / 2.
        room_cy[0] = ry + rh / 2.
        room_count = 1.
        placed = 1.
    <
    
    // Phase 2: Connect rooms with corridors
    /connect_rooms/.
    
    // Phase 3: Place player in random room
    player_room := /rng_int/room_count.
    player_x = room_cx[player_room].
    player_y = room_cy[player_room].
    player_prev_x = player_x.
    player_prev_y = player_y.
    anim_timer = 0.
    
    // Phase 4: Place stairs
    /place_stairs/.
    
    // Phase 5: Spawn gold
    /spawn_gold_piles/.
    
    // Phase 6: Spawn monsters
    /spawn_random_monsters/.
<

// ============================================================================
// Monster Spawning
// ============================================================================

#spawn_random_monsters() >
    /init_entities/.
    
    << 0 when dng_monster_count == 0.
    << 0 when room_count == 0.
    
    for i in 0..dng_monster_count >
        // Random Type based on unlocked monster types
        type := ENTITY_KOBOLD.
        // If goblins enabled, 50% chance of goblin
        roll := /rng_int/100.
        type = ENTITY_GOBLIN when dng_goblins_enabled == 1 and roll lt 50.
        
        // Random Position in a room (prefer non-player room)
        sx := 0.
        sy := 0.
        found := 0.
        
        tries := 0.
        loop when tries lt 100 and found == 0 >
            // Pick random room (try to avoid player's room)
            target := /rng_int/room_count.
            
            // Get room bounds
            trx := room_x[target].
            try := room_y[target].
            trw := room_w[target].
            trh := room_h[target].
            
            // Random position in interior
            int_w := trw - 2.
            int_h := trh - 2.
            
            // Safety check
            >< when int_w lt 1.
            >< when int_h lt 1.
            
            rx := trx + 1 + /rng_int/int_w.
            ry := try + 1 + /rng_int/int_h.
            
            tile := /get_tile/rx/ry.
            is_floor := 0.
            is_floor = 1 when tile == TILE_FLOOR.
            
            // Check player collision
            is_player := 0.
            same_x := 0.
            same_y := 0.
            same_x = 1 when rx == player_x.
            same_y = 1 when ry == player_y.
            is_player = same_x * same_y.
            
            // Check entity collision
            collision := /get_entity_at/rx/ry.
            is_occupied := 0.
            is_occupied = 1 when collision != -1.
            
            valid := is_floor * (1 - is_player) * (1 - is_occupied).
            
            sx = rx when valid == 1.
            sy = ry when valid == 1.
            found = valid.
            
            tries = tries + 1.
        <
        
        /spawn_entity/type/sx/sy when found == 1.
    <
<
