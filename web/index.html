<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>nh</title>
    <style>
        * { margin: 0; padding: 0; }
        body { background: #000; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
        .game { position: relative; width: 800px; height: 600px; }
        #canvas, #textCanvas { position: absolute; top: 0; left: 0; }
        #textCanvas { pointer-events: none; }
        @font-face {
            font-family: 'Berkeley Mono';
            src: url('TX-02-03LLJR61/BerkeleyMono-Regular.woff2') format('woff2');
        }
    </style>
</head>
<body>
    <div class="game">
        <canvas id="canvas" width="800" height="600"></canvas>
        <canvas id="textCanvas" width="800" height="600"></canvas>
    </div>
    <script src="game.js"></script>
    <script>
        const canvas = document.getElementById('canvas');
        const textCanvas = document.getElementById('textCanvas');
        window.textCtx = textCanvas.getContext('2d');
        
        let wasmModule = null;
        let lastTime = performance.now();
        
        const keyMap = {
            'ArrowLeft': 0, 'ArrowRight': 1, 'ArrowUp': 2, 'ArrowDown': 3,
            'Space': 4, 'Enter': 5,
            'KeyW': 6, 'KeyA': 7, 'KeyS': 8, 'KeyD': 9,
            'KeyH': 0, 'KeyL': 1, 'KeyK': 2, 'KeyJ': 3,
            'Period': 4
        };
        
        document.addEventListener('keydown', (e) => {
            const key = keyMap[e.code];
            if (key !== undefined && wasmModule) {
                wasmModule._on_key_down(key);
                e.preventDefault();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            const key = keyMap[e.code];
            if (key !== undefined && wasmModule) {
                wasmModule._on_key_up(key);
            }
        });
        
        function renderFrame(now) {
            if (!wasmModule) return;
            const dt = Math.floor(now - lastTime);
            lastTime = now;
            // Update and render first, THEN clear just_pressed flags for next frame
            wasmModule._game_update(dt);
            wasmModule._game_render();
            wasmModule._on_frame_start();  // Clear just_pressed AFTER reading them
            requestAnimationFrame(renderFrame);
        }
        
        async function init() {
            try {
                wasmModule = await createModule({
                    canvas: canvas,
                    print: (t) => console.log('[nh]', t),
                    printErr: (t) => console.error('[nh]', t)
                });
                await new Promise(r => requestAnimationFrame(r));
                wasmModule._game_init();
                lastTime = performance.now();
                requestAnimationFrame(renderFrame);
            } catch (e) {
                console.error('Init failed:', e);
            }
        }
        
        if (typeof createModule !== 'undefined') init();
    </script>
</body>
</html>
